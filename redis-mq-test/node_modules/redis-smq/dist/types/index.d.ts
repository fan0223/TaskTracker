/// <reference types="node" />
import { Message } from '../src/lib/message/message';
import { redisKeys } from '../src/common/redis-keys/redis-keys';
import { ICallback, TLoggerConfig, TRedisConfig } from 'redis-smq-common/dist/types';
import { RedisClient } from 'redis-smq-common';
export interface IEventProvider {
    on(event: string, listener: (...args: any[]) => void): void;
}
export interface IEventListener {
    quit(cb: ICallback<void>): void;
}
export declare type TConsumerEventListenerConstructor = new (redisClient: RedisClient, consumerId: string, queue: TQueueParams, eventProvider: IEventProvider) => IEventListener;
export declare type TProducerEventListenerConstructor = new (redisClient: RedisClient, producerId: string, eventProvider: IEventProvider) => IEventListener;
export interface IMessagesConfig {
    store?: boolean | IMessagesConfigStore;
}
export interface IMessagesConfigStoreOptions {
    queueSize?: number;
    expire?: number;
}
export interface IMessagesConfigStore {
    acknowledged?: boolean | IMessagesConfigStoreOptions;
    deadLettered?: boolean | IMessagesConfigStoreOptions;
}
export interface IEventListenersConfig {
    consumerEventListeners?: TConsumerEventListenerConstructor[];
    producerEventListeners?: TProducerEventListenerConstructor[];
}
export interface IConfig {
    redis?: TRedisConfig;
    namespace?: string;
    logger?: TLoggerConfig;
    messages?: IMessagesConfig;
    eventListeners?: IEventListenersConfig;
}
export interface IRequiredStoreMessagesParams extends Required<IMessagesConfigStoreOptions> {
    store: boolean;
}
export interface IRequiredMessagesConfigStore {
    acknowledged: IRequiredStoreMessagesParams;
    deadLettered: IRequiredStoreMessagesParams;
}
export declare type TRequiredEventListenersConfig = Required<IEventListenersConfig>;
export interface IRequiredConfig extends Required<IConfig> {
    messages: {
        store: IRequiredMessagesConfigStore;
    };
    eventListeners: TRequiredEventListenersConfig;
}
export declare type TPaginatedResponse<T> = {
    total: number;
    items: T[];
};
export declare type TGetMessagesReply = TPaginatedResponse<{
    sequenceId: number;
    message: Message;
}>;
export declare type TConsumerRedisKeys = ReturnType<typeof redisKeys['getConsumerKeys']>;
export declare type TQueueConsumerRedisKeys = ReturnType<typeof redisKeys['getQueueConsumerKeys']>;
export interface IQueueMetrics {
    acknowledged: number;
    deadLettered: number;
    pending: number;
}
export declare enum EMessageDeadLetterCause {
    TTL_EXPIRED = "ttl_expired",
    RETRY_THRESHOLD_EXCEEDED = "retry_threshold_exceeded",
    PERIODIC_MESSAGE = "periodic_message"
}
export declare enum EMessageUnacknowledgedCause {
    TIMEOUT = "timeout",
    CONSUME_ERROR = "consumer_error",
    UNACKNOWLEDGED = "unacknowledged",
    OFFLINE_CONSUMER = "offline_consumer",
    TTL_EXPIRED = "ttl_expired"
}
export declare type TQueueParams = {
    name: string;
    ns: string;
};
export declare type TQueueRateLimit = {
    limit: number;
    interval: number;
};
export declare type TQueueSettings = {
    priorityQueuing: boolean;
    rateLimit?: TQueueRateLimit | null;
};
export declare type TConsumerInfo = {
    ipAddress: string[];
    hostname: string;
    pid: number;
    createdAt: number;
};
export declare type TConsumerHeartbeat = {
    timestamp: number;
    data: TConsumerHeartbeatPayload;
};
export declare type TConsumerHeartbeatPayload = {
    ram: {
        usage: NodeJS.MemoryUsage;
        free: number;
        total: number;
    };
    cpu: {
        user: number;
        system: number;
        percentage: string;
    };
};
export declare type TConsumerMessageHandler = (msg: Message, cb: ICallback<void>) => void;
export declare type TConsumerMessageHandlerParams = {
    queue: TQueueParams;
    messageHandler: TConsumerMessageHandler;
};
export declare type TMessageJSON = {
    createdAt: number;
    queue: TQueueParams | null;
    ttl: number;
    retryThreshold: number;
    retryDelay: number;
    consumeTimeout: number;
    body: unknown;
    priority: number | null;
    scheduledCron: string | null;
    scheduledDelay: number | null;
    scheduledRepeatPeriod: number | null;
    scheduledRepeat: number;
    metadata: TMessageMetadataJSON | null;
};
export declare type TMessageMetadataJSON = {
    uuid: string;
    publishedAt: number | null;
    scheduledAt: number | null;
    scheduledCronFired: boolean;
    attempts: number;
    scheduledRepeatCount: number;
    expired: boolean;
    nextScheduledDelay: number;
    nextRetryDelay: number;
};
export declare type TMessageConsumeOptions = {
    ttl: number;
    retryThreshold: number;
    retryDelay: number;
    consumeTimeout: number;
};
