"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduleWorker = void 0;
const redis_keys_1 = require("../common/redis-keys/redis-keys");
const message_1 = require("../lib/message/message");
const redis_smq_common_1 = require("redis-smq-common");
const redis_client_1 = require("../common/redis-client/redis-client");
class ScheduleWorker extends redis_smq_common_1.Worker {
    constructor(redisClient, managed) {
        super(managed);
        this.fetchMessageIds = (cb) => {
            const { keyScheduledMessageWeight } = redis_keys_1.redisKeys.getMainKeys();
            this.redisClient.zrangebyscore(keyScheduledMessageWeight, 0, Date.now(), cb);
        };
        this.fetchMessages = (ids, cb) => {
            if (ids.length) {
                const { keyScheduledMessages } = redis_keys_1.redisKeys.getMainKeys();
                this.redisClient.hmget(keyScheduledMessages, ids, (err, reply) => {
                    if (err)
                        cb(err);
                    else {
                        const messages = [];
                        redis_smq_common_1.async.each(reply !== null && reply !== void 0 ? reply : [], (item, _, done) => {
                            if (!item)
                                done(new redis_smq_common_1.errors.EmptyCallbackReplyError());
                            else {
                                messages.push(message_1.Message.createFromMessage(item));
                                done();
                            }
                        }, (err) => {
                            if (err)
                                cb(err);
                            else
                                cb(null, messages);
                        });
                    }
                });
            }
            else
                cb(null, []);
        };
        this.enqueueMessages = (messages, cb) => {
            if (messages.length) {
                redis_smq_common_1.async.each(messages, (msg, _, done) => {
                    var _a;
                    const message = message_1.Message.createFromMessage(msg);
                    const queue = message.getRequiredQueue();
                    const { keyQueueSettings, keyQueueSettingsPriorityQueuing, keyQueuePending, keyQueuePendingPriorityMessages, keyQueuePendingPriorityMessageWeight, keyScheduledMessageWeight, keyScheduledMessages, } = redis_keys_1.redisKeys.getQueueKeys(queue);
                    const nextScheduleTimestamp = message.getNextScheduledTimestamp();
                    message.getRequiredMetadata().setPublishedAt(Date.now());
                    this.redisClient.runScript(redis_client_1.ELuaScriptName.ENQUEUE_SCHEDULED_MESSAGE, [
                        keyQueueSettings,
                        keyQueueSettingsPriorityQueuing,
                        keyQueuePendingPriorityMessages,
                        keyQueuePendingPriorityMessageWeight,
                        keyQueuePending,
                        keyScheduledMessageWeight,
                        keyScheduledMessages,
                    ], [
                        message.getRequiredId(),
                        JSON.stringify(message),
                        (_a = message.getPriority()) !== null && _a !== void 0 ? _a : '',
                        `${nextScheduleTimestamp}`,
                    ], (err) => done(err));
                }, cb);
            }
            else
                cb();
        };
        this.work = (cb) => {
            redis_smq_common_1.async.waterfall([this.fetchMessageIds, this.fetchMessages, this.enqueueMessages], cb);
        };
        this.redisClient = redisClient;
    }
}
exports.ScheduleWorker = ScheduleWorker;
exports.default = ScheduleWorker;
//# sourceMappingURL=schedule.worker.js.map