"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WatchdogWorker = void 0;
const consumer_heartbeat_1 = require("../lib/consumer/consumer-heartbeat");
const redis_smq_common_1 = require("redis-smq-common");
const consumer_queues_1 = require("../lib/consumer/consumer-queues");
const message_handler_1 = require("../lib/consumer/consumer-message-handler/message-handler");
const retry_message_1 = require("../lib/consumer/consumer-message-handler/retry-message");
class WatchdogWorker extends redis_smq_common_1.Worker {
    constructor(redisClient, config, managed, logger) {
        super(managed);
        this.work = (cb) => {
            consumer_heartbeat_1.ConsumerHeartbeat.getExpiredHeartbeatIds(this.redisClient, (err, reply) => {
                if (err)
                    cb(err);
                else {
                    const ids = reply !== null && reply !== void 0 ? reply : [];
                    if (ids.length) {
                        const statuses = [];
                        const multi = this.redisClient.multi();
                        redis_smq_common_1.async.each(ids, (consumerId, key, callback) => {
                            consumer_heartbeat_1.ConsumerHeartbeat.handleExpiredHeartbeatId(consumerId, multi);
                            consumer_queues_1.consumerQueues.getConsumerQueues(this.redisClient, consumerId, (err, reply) => {
                                if (err)
                                    callback(err);
                                else {
                                    const queues = reply !== null && reply !== void 0 ? reply : [];
                                    redis_smq_common_1.async.each(queues, (queue, _, done) => {
                                        message_handler_1.MessageHandler.cleanUp(this.config, this.redisClient, consumerId, queue, multi, (err, reply) => {
                                            if (err)
                                                done(err);
                                            else {
                                                statuses.push(reply !== null && reply !== void 0 ? reply : false);
                                                done();
                                            }
                                        });
                                    }, callback);
                                }
                            });
                        }, (err) => {
                            if (err)
                                cb(err);
                            else {
                                multi.exec((err) => {
                                    if (err)
                                        cb(err);
                                    else {
                                        statuses.forEach((cleanUpStatus) => {
                                            if (cleanUpStatus) {
                                                this.logger.debug(`Message ID ${cleanUpStatus.message.getId()} has been ${cleanUpStatus.status ===
                                                    retry_message_1.ERetryStatus.MESSAGE_DEAD_LETTERED
                                                    ? 'dead-lettered'
                                                    : 'unacknowledged'}.`);
                                            }
                                        });
                                        cb();
                                    }
                                });
                            }
                        });
                    }
                    else
                        cb();
                }
            });
        };
        this.redisClient = redisClient;
        this.config = config;
        this.logger = logger;
    }
}
exports.WatchdogWorker = WatchdogWorker;
exports.default = WatchdogWorker;
//# sourceMappingURL=watchdog.worker.js.map