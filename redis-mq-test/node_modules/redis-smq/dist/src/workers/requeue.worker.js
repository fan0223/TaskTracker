"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequeueWorker = void 0;
const redis_keys_1 = require("../common/redis-keys/redis-keys");
const message_1 = require("../lib/message/message");
const redis_smq_common_1 = require("redis-smq-common");
class RequeueWorker extends redis_smq_common_1.Worker {
    constructor(redisClient, managed) {
        super(managed);
        this.work = (cb) => {
            const { keyRequeueMessages } = this.redisKeys;
            this.redisClient.lrange(keyRequeueMessages, 0, 99, (err, reply) => {
                if (err)
                    cb(err);
                else {
                    const messages = reply !== null && reply !== void 0 ? reply : [];
                    if (messages.length) {
                        const multi = this.redisClient.multi();
                        redis_smq_common_1.async.each(messages, (messageStr, _, done) => {
                            const message = message_1.Message.createFromMessage(messageStr);
                            const queue = message.getRequiredQueue();
                            const { keyQueuePending, keyQueuePendingPriorityMessageWeight } = redis_keys_1.redisKeys.getQueueKeys(queue);
                            multi.lrem(keyRequeueMessages, 1, messageStr);
                            message.getRequiredMetadata().incrAttempts();
                            if (message.hasPriority()) {
                                const priority = message.getPriority();
                                if (priority === null)
                                    done(new redis_smq_common_1.errors.PanicError(`Expected a non-empty message priority value`));
                                else {
                                    multi.zadd(keyQueuePendingPriorityMessageWeight, priority, JSON.stringify(message));
                                }
                            }
                            else
                                multi.lpush(keyQueuePending, JSON.stringify(message));
                            done();
                        }, (err) => {
                            if (err)
                                cb(err);
                            else
                                multi.exec((err) => cb(err));
                        });
                    }
                    else
                        cb();
                }
            });
        };
        this.redisClient = redisClient;
        this.redisKeys = redis_keys_1.redisKeys.getMainKeys();
    }
}
exports.RequeueWorker = RequeueWorker;
exports.default = RequeueWorker;
//# sourceMappingURL=requeue.worker.js.map