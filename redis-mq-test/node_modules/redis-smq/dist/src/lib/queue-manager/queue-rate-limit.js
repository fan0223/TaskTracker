"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueueRateLimit = void 0;
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const queue_rate_limit_error_1 = require("./errors/queue-rate-limit.error");
const queue_1 = require("./queue");
const redis_client_1 = require("../../common/redis-client/redis-client");
class QueueRateLimit {
    constructor(config, redisClient, logger) {
        this.redisClient = redisClient;
        this.logger = logger;
        this.config = config;
    }
    clear(queue, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        const { keyQueueSettings, keyQueueSettingsRateLimit, keyQueueRateLimitCounter, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        const multi = this.redisClient.multi();
        multi.hdel(keyQueueSettings, keyQueueSettingsRateLimit);
        multi.del(keyQueueRateLimitCounter);
        multi.exec((err) => cb(err));
    }
    set(queue, rateLimit, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        const limit = Number(rateLimit.limit);
        if (isNaN(limit) || limit <= 0) {
            cb(new queue_rate_limit_error_1.QueueRateLimitError(`Invalid rateLimit.limit. Expected a positive integer > 0`));
        }
        const interval = Number(rateLimit.interval);
        if (isNaN(interval) || interval < 1000) {
            cb(new queue_rate_limit_error_1.QueueRateLimitError(`Invalid rateLimit.interval. Expected a positive integer >= 1000`));
        }
        const validatedRateLimit = { interval, limit };
        const { keyQueueSettings, keyQueueSettingsRateLimit } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        this.redisClient.hset(keyQueueSettings, keyQueueSettingsRateLimit, JSON.stringify(validatedRateLimit), (err) => cb(err));
    }
    get(queue, cb) {
        QueueRateLimit.get(this.config, this.redisClient, queue, cb);
    }
    static hasExceeded(redisClient, queue, rateLimit, cb) {
        const { limit, interval } = rateLimit;
        const { keyQueueRateLimitCounter } = redis_keys_1.redisKeys.getQueueKeys(queue);
        redisClient.runScript(redis_client_1.ELuaScriptName.HAS_QUEUE_RATE_EXCEEDED, [keyQueueRateLimitCounter], [limit, interval], (err, reply) => {
            if (err)
                cb(err);
            else {
                const hasExceeded = Boolean(reply);
                cb(null, hasExceeded);
            }
        });
    }
    static get(config, redisClient, queue, cb) {
        const queueParams = queue_1.Queue.getParams(config, queue);
        const { keyQueueSettings, keyQueueSettingsRateLimit } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        redisClient.hget(keyQueueSettings, keyQueueSettingsRateLimit, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply)
                cb(null, null);
            else {
                const rateLimit = JSON.parse(reply);
                cb(null, rateLimit);
            }
        });
    }
}
exports.QueueRateLimit = QueueRateLimit;
//# sourceMappingURL=queue-rate-limit.js.map