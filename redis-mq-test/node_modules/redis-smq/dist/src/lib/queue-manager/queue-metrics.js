"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueueMetrics = void 0;
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const redis_smq_common_1 = require("redis-smq-common");
const queue_1 = require("./queue");
class QueueMetrics {
    constructor(config, redisClient, logger) {
        this.redisClient = redisClient;
        this.logger = logger;
        this.config = config;
    }
    getMetrics(queue, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        const queueMetrics = {
            acknowledged: 0,
            deadLettered: 0,
            pending: 0,
        };
        const { keyQueuePending, keyQueuePendingPriorityMessageWeight, keyQueueDL, keyQueueAcknowledged, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        redis_smq_common_1.async.waterfall([
            (cb) => queue_1.Queue.getSettings(this.config, this.redisClient, queueParams, (err, settings) => {
                if (err)
                    cb(err);
                if (!settings)
                    cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
                else
                    cb(null, settings.priorityQueuing);
            }),
            (priorityQueuing, cb) => {
                if (priorityQueuing) {
                    this.redisClient.zcard(keyQueuePendingPriorityMessageWeight, (err, reply) => {
                        if (err)
                            cb(err);
                        else {
                            queueMetrics.pending = reply !== null && reply !== void 0 ? reply : 0;
                            cb();
                        }
                    });
                }
                else {
                    this.redisClient.llen(keyQueuePending, (err, reply) => {
                        if (err)
                            cb(err);
                        else {
                            queueMetrics.pending = reply !== null && reply !== void 0 ? reply : 0;
                            cb();
                        }
                    });
                }
            },
            (cb) => {
                this.redisClient.llen(keyQueueDL, (err, reply) => {
                    if (err)
                        cb(err);
                    else {
                        queueMetrics.deadLettered = reply !== null && reply !== void 0 ? reply : 0;
                        cb();
                    }
                });
            },
            (cb) => {
                this.redisClient.llen(keyQueueAcknowledged, (err, reply) => {
                    if (err)
                        cb(err);
                    else {
                        queueMetrics.acknowledged = reply !== null && reply !== void 0 ? reply : 0;
                        cb();
                    }
                });
            },
        ], (err) => {
            if (err)
                cb(err);
            else
                cb(null, queueMetrics);
        });
    }
}
exports.QueueMetrics = QueueMetrics;
//# sourceMappingURL=queue-metrics.js.map