"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueueManager = void 0;
const queue_rate_limit_1 = require("./queue-rate-limit");
const namespace_1 = require("./namespace");
const queue_metrics_1 = require("./queue-metrics");
const queue_1 = require("./queue");
const redis_smq_common_1 = require("redis-smq-common");
const configuration_1 = require("../../config/configuration");
class QueueManager {
    constructor(redisClient, namespace, queue, queueRateLimit, queueMetrics) {
        this.redisClient = redisClient;
        this.namespace = namespace;
        this.queue = queue;
        this.queueRateLimit = queueRateLimit;
        this.queueMetrics = queueMetrics;
    }
    quit(cb) {
        this.redisClient.halt(cb);
    }
    static createInstance(config, cb) {
        const cfg = (0, configuration_1.getConfiguration)(config);
        const redis = cfg.redis;
        (0, redis_smq_common_1.createClientInstance)(redis, (err, client) => {
            if (err)
                cb(err);
            else if (!client)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else {
                const loggerCfg = cfg.logger;
                const nsLogger = redis_smq_common_1.logger.getNamespacedLogger(loggerCfg, 'queue-manager');
                const namespace = new namespace_1.Namespace(cfg, client, nsLogger);
                const queue = new queue_1.Queue(cfg, client, nsLogger);
                const queueRateLimit = new queue_rate_limit_1.QueueRateLimit(cfg, client, nsLogger);
                const queueMetrics = new queue_metrics_1.QueueMetrics(cfg, client, nsLogger);
                cb(null, new QueueManager(client, namespace, queue, queueRateLimit, queueMetrics));
            }
        });
    }
}
exports.QueueManager = QueueManager;
//# sourceMappingURL=queue-manager.js.map