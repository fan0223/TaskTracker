"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Namespace = void 0;
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const redis_smq_common_1 = require("redis-smq-common");
const namespace_not_found_error_1 = require("./errors/namespace-not-found.error");
const delete_queue_transaction_1 = require("./delete-queue-transaction");
class Namespace {
    constructor(config, redisClient, logger) {
        this.redisClient = redisClient;
        this.logger = logger;
        this.config = config;
    }
    list(cb) {
        const { keyNamespaces } = redis_keys_1.redisKeys.getMainKeys();
        this.redisClient.smembers(keyNamespaces, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else
                cb(null, reply);
        });
    }
    getQueues(namespace, cb) {
        const { keyNsQueues } = redis_keys_1.redisKeys.getNamespaceKeys(namespace);
        this.redisClient.smembers(keyNsQueues, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else {
                const messageQueues = reply.map((i) => JSON.parse(i));
                cb(null, messageQueues);
            }
        });
    }
    delete(ns, cb) {
        const { keyNamespaces } = redis_keys_1.redisKeys.getMainKeys();
        redis_smq_common_1.async.waterfall([
            (cb) => {
                this.redisClient.sismember(keyNamespaces, ns, (err, isMember) => {
                    if (err)
                        cb(err);
                    else if (!isMember)
                        cb(new namespace_not_found_error_1.NamespaceNotFoundError(ns));
                    else
                        cb();
                });
            },
        ], (err) => {
            if (err)
                cb(err);
            else {
                this.getQueues(ns, (err, reply) => {
                    if (err)
                        cb(err);
                    else {
                        const queues = reply !== null && reply !== void 0 ? reply : [];
                        const multi = this.redisClient.multi();
                        multi.srem(keyNamespaces, ns);
                        redis_smq_common_1.async.eachOf(queues, (queueParams, _, done) => {
                            (0, delete_queue_transaction_1.initDeleteQueueTransaction)(this.config, this.redisClient, queueParams, multi, (err) => done(err));
                        }, (err) => {
                            if (err)
                                cb(err);
                            else
                                multi.exec((err) => cb(err));
                        });
                    }
                });
            }
        });
    }
}
exports.Namespace = Namespace;
//# sourceMappingURL=namespace.js.map