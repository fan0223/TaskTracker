"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initDeleteQueueTransaction = void 0;
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const redis_smq_common_1 = require("redis-smq-common");
const processing_queue_1 = require("../consumer/consumer-message-handler/processing-queue");
const consumer_heartbeat_1 = require("../consumer/consumer-heartbeat");
const consumer_1 = require("../consumer/consumer");
const queue_1 = require("./queue");
const queue_not_found_error_1 = require("./errors/queue-not-found.error");
function validateMessageQueueDeletion(redisClient, queue, cb) {
    const verifyHeartbeats = (consumerIds, cb) => {
        if (consumerIds.length) {
            consumer_heartbeat_1.ConsumerHeartbeat.validateHeartbeatsOf(redisClient, consumerIds, (err, reply) => {
                if (err)
                    cb(err);
                else {
                    const r = reply !== null && reply !== void 0 ? reply : {};
                    const onlineArr = Object.keys(r).filter((id) => r[id]);
                    if (onlineArr.length) {
                        cb(new redis_smq_common_1.errors.GenericError(`Before deleting a queue/namespace, make sure it is not used by a message handler. After shutting down all message handlers, wait a few seconds and try again.`));
                    }
                    else
                        cb();
                }
            });
        }
        else
            cb();
    };
    const getOnlineConsumers = (cb) => {
        consumer_1.Consumer.getOnlineConsumerIds(redisClient, queue, cb);
    };
    redis_smq_common_1.async.waterfall([getOnlineConsumers, verifyHeartbeats], (err) => cb(err));
}
function initDeleteQueueTransaction(config, redisClient, queueParams, multi, cb) {
    const { keyQueuePending, keyQueueDL, keyQueueProcessingQueues, keyQueuePendingPriorityMessageWeight, keyQueueAcknowledged, keyQueuePendingPriorityMessages, keyQueueConsumers, keyProcessingQueues, keyQueues, keyNsQueues, keyQueueRateLimitCounter, keyQueueSettings, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
    const keys = [
        keyQueuePending,
        keyQueueDL,
        keyQueueProcessingQueues,
        keyQueuePendingPriorityMessageWeight,
        keyQueueAcknowledged,
        keyQueuePendingPriorityMessages,
        keyQueueConsumers,
        keyQueueRateLimitCounter,
        keyQueueSettings,
    ];
    redisClient.watch([keyQueueConsumers, keyQueueProcessingQueues, keyQueueSettings], (err) => {
        if (err)
            cb(err);
        else {
            redis_smq_common_1.async.waterfall([
                (cb) => queue_1.Queue.exists(config, redisClient, queueParams, (err, reply) => {
                    if (err)
                        cb(err);
                    else if (!reply)
                        cb(new queue_not_found_error_1.QueueNotFoundError());
                    else
                        cb();
                }),
                (cb) => validateMessageQueueDeletion(redisClient, queueParams, cb),
                (cb) => {
                    processing_queue_1.processingQueue.getQueueProcessingQueues(redisClient, queueParams, (err, reply) => {
                        if (err)
                            cb(err);
                        else {
                            const pQueues = Object.keys(reply !== null && reply !== void 0 ? reply : {});
                            cb(null, pQueues);
                        }
                    });
                },
            ], (err, processingQueues) => {
                if (err)
                    redisClient.unwatch(() => cb(err));
                else {
                    const tx = multi || redisClient.multi();
                    const str = JSON.stringify(queueParams);
                    tx.srem(keyQueues, str);
                    tx.srem(keyNsQueues, str);
                    const pQueues = processingQueues !== null && processingQueues !== void 0 ? processingQueues : [];
                    if (pQueues.length) {
                        keys.push(...pQueues);
                        tx.srem(keyProcessingQueues, pQueues);
                    }
                    tx.del(keys);
                    cb(null, tx);
                }
            });
        }
    });
}
exports.initDeleteQueueTransaction = initDeleteQueueTransaction;
//# sourceMappingURL=delete-queue-transaction.js.map