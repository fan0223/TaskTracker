"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const queue_exists_error_1 = require("./errors/queue-exists.error");
const queue_not_found_error_1 = require("./errors/queue-not-found.error");
const delete_queue_transaction_1 = require("./delete-queue-transaction");
const redis_smq_common_1 = require("redis-smq-common");
const redis_client_1 = require("../../common/redis-client/redis-client");
class Queue {
    constructor(config, redisClient, logger) {
        this.config = config;
        this.redisClient = redisClient;
        this.logger = logger;
    }
    create(queue, priorityQueuing, cb) {
        const queueParams = Queue.getParams(this.config, queue);
        const { keyQueues, keyNsQueues, keyNamespaces, keyQueueSettings, keyQueueSettingsPriorityQueuing, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        const queueIndex = JSON.stringify(queueParams);
        this.redisClient.runScript(redis_client_1.ELuaScriptName.CREATE_QUEUE, [
            keyNamespaces,
            keyNsQueues,
            keyQueues,
            keyQueueSettings,
            keyQueueSettingsPriorityQueuing,
        ], [queueParams.ns, queueIndex, JSON.stringify(priorityQueuing)], (err, reply) => {
            if (err)
                cb(err);
            else if (!reply)
                cb(new queue_exists_error_1.QueueExistsError());
            else
                cb();
        });
    }
    getSettings(queue, cb) {
        Queue.getSettings(this.config, this.redisClient, queue, cb);
    }
    exists(queue, cb) {
        Queue.exists(this.config, this.redisClient, queue, cb);
    }
    list(cb) {
        Queue.list(this.redisClient, cb);
    }
    delete(queue, cb) {
        const queueParams = Queue.getParams(this.config, queue);
        (0, delete_queue_transaction_1.initDeleteQueueTransaction)(this.config, this.redisClient, queueParams, undefined, (err, multi) => {
            if (err)
                cb(err);
            else if (!multi)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else
                multi.exec((err) => cb(err));
        });
    }
    static getParams(config, queue) {
        const queueParams = typeof queue === 'string' ? { name: queue } : queue;
        const name = redis_keys_1.redisKeys.validateRedisKey(queueParams.name);
        const ns = queueParams.ns
            ? redis_keys_1.redisKeys.validateNamespace(queueParams.ns)
            : config.namespace;
        return {
            name,
            ns,
        };
    }
    static getSettings(config, redisClient, queue, cb) {
        const queueParams = Queue.getParams(config, queue);
        const { keyQueueSettings, keyQueueSettingsPriorityQueuing, keyQueueSettingsRateLimit, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        redisClient.hgetall(keyQueueSettings, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply || !Object.keys(reply).length)
                cb(new queue_not_found_error_1.QueueNotFoundError());
            else {
                const queueSettings = { priorityQueuing: false };
                for (const key in reply) {
                    if (key === keyQueueSettingsPriorityQueuing) {
                        queueSettings.priorityQueuing = JSON.parse(reply[key]);
                    }
                    if (key === keyQueueSettingsRateLimit) {
                        queueSettings.rateLimit = JSON.parse(reply[key]);
                    }
                }
                cb(null, queueSettings);
            }
        });
    }
    static list(redisClient, cb) {
        const { keyQueues } = redis_keys_1.redisKeys.getMainKeys();
        redisClient.smembers(keyQueues, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else {
                const messageQueues = reply.map((i) => JSON.parse(i));
                cb(null, messageQueues);
            }
        });
    }
    static exists(config, redisClient, queue, cb) {
        const queueParams = Queue.getParams(config, queue);
        const { keyQueues } = redis_keys_1.redisKeys.getMainKeys();
        redisClient.sismember(keyQueues, JSON.stringify(queueParams), (err, reply) => {
            if (err)
                cb(err);
            else
                cb(null, !!reply);
        });
    }
}
exports.Queue = Queue;
//# sourceMappingURL=queue.js.map