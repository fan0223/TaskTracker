"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsumeMessage = void 0;
const message_1 = require("../../message/message");
const types_1 = require("../../../../types");
const events_1 = require("../../../common/events/events");
const redis_keys_1 = require("../../../common/redis-keys/redis-keys");
const redis_smq_common_1 = require("redis-smq-common");
const retry_message_1 = require("./retry-message");
const acknowledge_message_1 = require("./acknowledge-message");
class ConsumeMessage {
    constructor(messageHandler, redisClient, logger) {
        this.redisClient = redisClient;
        this.messageHandler = messageHandler;
        const { keyQueueProcessing } = redis_keys_1.redisKeys.getQueueConsumerKeys(messageHandler.getQueue(), messageHandler.getConsumerId());
        this.keyQueueProcessing = keyQueueProcessing;
        this.logger = logger;
    }
    unacknowledgeMessage(msg, cause) {
        (0, retry_message_1.retryMessage)(this.messageHandler.getConfig(), this.redisClient, this.keyQueueProcessing, msg, cause, (err, retryStatus) => {
            if (err)
                this.messageHandler.handleError(err);
            else if (!retryStatus)
                this.messageHandler.handleError(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else {
                this.messageHandler.emit(events_1.events.MESSAGE_UNACKNOWLEDGED, msg, types_1.EMessageUnacknowledgedCause.CONSUME_ERROR);
                if (retryStatus.status === retry_message_1.ERetryStatus.MESSAGE_DEAD_LETTERED) {
                    this.messageHandler.emit(events_1.events.MESSAGE_DEAD_LETTERED, msg);
                }
            }
        });
    }
    consumeMessage(msg) {
        let isTimeout = false;
        let timer = null;
        try {
            const consumeTimeout = msg.getConsumeTimeout();
            if (consumeTimeout) {
                timer = setTimeout(() => {
                    isTimeout = true;
                    timer = null;
                    this.unacknowledgeMessage(msg, types_1.EMessageUnacknowledgedCause.TIMEOUT);
                }, consumeTimeout);
            }
            const onConsumed = (err) => {
                if (this.messageHandler.isRunning() && !isTimeout) {
                    if (timer)
                        clearTimeout(timer);
                    if (err) {
                        this.logger.error(err);
                        this.unacknowledgeMessage(msg, types_1.EMessageUnacknowledgedCause.UNACKNOWLEDGED);
                    }
                    else {
                        (0, acknowledge_message_1.acknowledgeMessage)(this.messageHandler.getConfig(), this.redisClient, msg, this.keyQueueProcessing, (err) => {
                            if (err)
                                this.messageHandler.handleError(err);
                            else
                                this.messageHandler.emit(events_1.events.MESSAGE_ACKNOWLEDGED, msg);
                        });
                    }
                }
            };
            this.messageHandler.getHandler()(message_1.Message.createFromMessage(msg), onConsumed);
        }
        catch (error) {
            this.logger.error(error);
            this.unacknowledgeMessage(msg, types_1.EMessageUnacknowledgedCause.CONSUME_ERROR);
        }
    }
    handleReceivedMessage(message) {
        if (message.getSetExpired()) {
            this.unacknowledgeMessage(message, types_1.EMessageUnacknowledgedCause.TTL_EXPIRED);
        }
        else
            this.consumeMessage(message);
    }
}
exports.ConsumeMessage = ConsumeMessage;
//# sourceMappingURL=consume-message.js.map