"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processingQueue = void 0;
const types_1 = require("../../../../types");
const message_1 = require("../../message/message");
const redis_smq_common_1 = require("redis-smq-common");
const redis_keys_1 = require("../../../common/redis-keys/redis-keys");
const retry_message_1 = require("./retry-message");
function fetchProcessingQueueMessage(redisClient, keyQueueProcessing, cb) {
    redisClient.lrange(keyQueueProcessing, 0, 0, (err, range) => {
        if (err)
            cb(err);
        else if (range && range.length) {
            const msg = message_1.Message.createFromMessage(range[0]);
            cb(null, msg);
        }
        else
            cb();
    });
}
function deleteProcessingQueue(multi, queue, processingQueue) {
    const { keyProcessingQueues, keyQueueProcessingQueues } = redis_keys_1.redisKeys.getQueueKeys(queue);
    multi.srem(keyProcessingQueues, processingQueue);
    multi.hdel(keyQueueProcessingQueues, processingQueue);
    multi.del(processingQueue);
}
exports.processingQueue = {
    cleanUpProcessingQueue(config, redisClient, consumerId, queue, multi, cb) {
        const { keyQueueProcessing } = redis_keys_1.redisKeys.getQueueConsumerKeys(queue, consumerId);
        let status = false;
        redis_smq_common_1.async.waterfall([
            (cb) => {
                fetchProcessingQueueMessage(redisClient, keyQueueProcessing, (err, msg) => {
                    if (err)
                        cb(err);
                    else if (msg) {
                        status = (0, retry_message_1.retryMessage)(config, multi, keyQueueProcessing, msg, types_1.EMessageUnacknowledgedCause.OFFLINE_CONSUMER);
                        cb();
                    }
                    else
                        cb();
                });
            },
            (cb) => {
                deleteProcessingQueue(multi, queue, keyQueueProcessing);
                cb();
            },
        ], (err) => {
            if (err)
                cb(err);
            else
                cb(null, status);
        });
    },
    setUpProcessingQueue(multi, queue, consumerId) {
        const { keyQueueProcessing, keyProcessingQueues, keyQueueProcessingQueues, } = redis_keys_1.redisKeys.getQueueConsumerKeys(queue, consumerId);
        multi.hset(keyQueueProcessingQueues, keyQueueProcessing, consumerId);
        multi.sadd(keyProcessingQueues, keyQueueProcessing);
    },
    getQueueProcessingQueues(redisClient, queue, cb) {
        const { keyQueueProcessingQueues } = redis_keys_1.redisKeys.getQueueKeys(queue);
        redisClient.hgetall(keyQueueProcessingQueues, cb);
    },
};
//# sourceMappingURL=processing-queue.js.map