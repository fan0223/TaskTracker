"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiplexedDequeueMessage = void 0;
const dequeue_message_1 = require("../dequeue-message");
const message_1 = require("../../../message/message");
const events_1 = require("../../../../common/events/events");
const queue_rate_limit_1 = require("../../../queue-manager/queue-rate-limit");
class MultiplexedDequeueMessage extends dequeue_message_1.DequeueMessage {
    dequeue() {
        const cb = (err, reply) => {
            if (err) {
                this.ticker.abort();
                this.messageHandler.handleError(err);
            }
            else if (typeof reply === 'string') {
                const message = message_1.Message.createFromMessage(reply);
                this.messageHandler.emit(events_1.events.MESSAGE_RECEIVED, message);
            }
            else {
                this.messageHandler.emit(events_1.events.MESSAGE_NEXT);
            }
        };
        const deq = () => {
            if (this.priorityQueuing)
                this.dequeueMessageWithPriority(cb);
            else
                this.dequeueMessage(cb);
        };
        if (this.queueRateLimit) {
            queue_rate_limit_1.QueueRateLimit.hasExceeded(this.redisClient, this.queue, this.queueRateLimit, (err, isExceeded) => {
                if (err)
                    this.messageHandler.handleError(err);
                else if (isExceeded)
                    this.messageHandler.emit(events_1.events.MESSAGE_NEXT);
                else
                    deq();
            });
        }
        else
            deq();
    }
}
exports.MultiplexedDequeueMessage = MultiplexedDequeueMessage;
//# sourceMappingURL=multiplexed-dequeue-message.js.map