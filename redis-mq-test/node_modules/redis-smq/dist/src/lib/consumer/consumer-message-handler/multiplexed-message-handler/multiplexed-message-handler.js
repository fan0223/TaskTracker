"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiplexedMessageHandler = void 0;
const message_handler_1 = require("../message-handler");
const events_1 = require("../../../../common/events/events");
const multiplexed_dequeue_message_1 = require("./multiplexed-dequeue-message");
const redis_smq_common_1 = require("redis-smq-common");
class MultiplexedMessageHandler extends message_handler_1.MessageHandler {
    constructor(consumer, queue, handler, dequeueRedisClient, sharedRedisClient, logger) {
        super(consumer, queue, handler, dequeueRedisClient, sharedRedisClient, logger);
        this.dequeueMessage = new multiplexed_dequeue_message_1.MultiplexedDequeueMessage(this, dequeueRedisClient);
    }
    registerEventsHandlers() {
        super.registerEventsHandlers();
        this.removeAllListeners(events_1.events.MESSAGE_NEXT);
        this.removeAllListeners(events_1.events.UP);
        this.on(events_1.events.UP, () => {
            this.logger.info('Up and running...');
        });
    }
    shutdown(cb) {
        const goDown = () => {
            this.powerManager.goingDown();
            redis_smq_common_1.async.waterfall([
                (cb) => this.dequeueMessage.quit(cb),
                (cb) => this.tearDownEventListeners(cb),
                (cb) => this.cleanUp(cb),
            ], (err) => {
                if (err)
                    cb(err);
                else {
                    this.powerManager.commit();
                    this.emit(events_1.events.DOWN);
                    cb();
                }
            });
        };
        if (this.powerManager.isGoingUp())
            this.once(events_1.events.UP, goDown);
        else
            goDown();
    }
}
exports.MultiplexedMessageHandler = MultiplexedMessageHandler;
//# sourceMappingURL=multiplexed-message-handler.js.map