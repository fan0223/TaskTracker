/// <reference types="node" />
import { IEventListener, IRequiredConfig, TConsumerMessageHandler, TQueueParams } from '../../../../types';
import { EventEmitter } from 'events';
import { TCleanUpStatus } from './processing-queue';
import { DequeueMessage } from './dequeue-message';
import { ConsumeMessage } from './consume-message';
import { Consumer } from '../consumer';
import { PowerManager, RedisClient } from 'redis-smq-common';
import { ICallback, ICompatibleLogger, IRedisClientMulti } from 'redis-smq-common/dist/types';
export declare class MessageHandler extends EventEmitter {
    protected id: string;
    protected consumer: Consumer;
    protected consumerId: string;
    protected queue: TQueueParams;
    protected dequeueRedisClient: RedisClient;
    protected sharedRedisClient: RedisClient;
    protected powerManager: PowerManager;
    protected logger: ICompatibleLogger;
    protected dequeueMessage: DequeueMessage;
    protected consumeMessage: ConsumeMessage;
    protected handler: TConsumerMessageHandler;
    protected eventListeners: IEventListener[];
    constructor(consumer: Consumer, queue: TQueueParams, handler: TConsumerMessageHandler, dequeueRedisClient: RedisClient, sharedRedisClient: RedisClient, logger: ICompatibleLogger);
    protected registerEventsHandlers(): void;
    protected initEventListeners(): void;
    protected cleanUp(cb: ICallback<void>): void;
    protected tearDownEventListeners(cb: ICallback<void>): void;
    handleError(err: Error): void;
    dequeue(): void;
    run(cb: ICallback<void>): void;
    shutdown(cb: ICallback<void>): void;
    getQueue(): TQueueParams;
    getConsumerId(): string;
    getId(): string;
    getConfig(): IRequiredConfig;
    isRunning(): boolean;
    getHandler(): TConsumerMessageHandler;
    static cleanUp(config: IRequiredConfig, redisClient: RedisClient, consumerId: string, queue: TQueueParams, pendingMulti: IRedisClientMulti | undefined, cb: ICallback<TCleanUpStatus>): void;
}
