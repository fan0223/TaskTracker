"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageHandlerRunner = void 0;
const message_handler_1 = require("./message-handler");
const events_1 = require("../../../common/events/events");
const redis_smq_common_1 = require("redis-smq-common");
const message_handler_already_exists_error_1 = require("../errors/message-handler-already-exists.error");
class MessageHandlerRunner {
    constructor(consumer, logger) {
        this.sharedRedisClient = null;
        this.messageHandlerInstances = [];
        this.messageHandlers = [];
        this.consumer = consumer;
        this.config = consumer.getConfig();
        this.logger = logger;
    }
    registerMessageHandlerEvents(messageHandler) {
        messageHandler.on(events_1.events.ERROR, (...args) => this.consumer.emit(events_1.events.ERROR, ...args));
        messageHandler.on(events_1.events.MESSAGE_UNACKNOWLEDGED, (...args) => this.consumer.emit(events_1.events.MESSAGE_UNACKNOWLEDGED, ...args));
        messageHandler.on(events_1.events.MESSAGE_DEAD_LETTERED, (...args) => this.consumer.emit(events_1.events.MESSAGE_DEAD_LETTERED, ...args));
        messageHandler.on(events_1.events.MESSAGE_ACKNOWLEDGED, (...args) => this.consumer.emit(events_1.events.MESSAGE_ACKNOWLEDGED, ...args));
        messageHandler.on(events_1.events.MESSAGE_RECEIVED, (...args) => this.consumer.emit(events_1.events.MESSAGE_RECEIVED, ...args));
    }
    getMessageHandlerInstance(queue) {
        return this.messageHandlerInstances.find((i) => {
            const q = i.getQueue();
            return q.name === queue.name && q.ns === queue.ns;
        });
    }
    getMessageHandler(queue) {
        return this.messageHandlers.find((i) => i.queue.name === queue.name && i.queue.ns === queue.ns);
    }
    createMessageHandlerInstance(dequeueRedisClient, handlerParams) {
        const sharedRedisClient = this.getSharedRedisClient();
        const { queue, messageHandler } = handlerParams;
        const instance = new message_handler_1.MessageHandler(this.consumer, queue, messageHandler, dequeueRedisClient, sharedRedisClient, this.logger);
        this.registerMessageHandlerEvents(instance);
        this.messageHandlerInstances.push(instance);
        this.logger.info(`Created a new instance (ID: ${instance.getId()}) for MessageHandler (${JSON.stringify(handlerParams)}).`);
        return instance;
    }
    runMessageHandler(handlerParams, cb) {
        const { redis } = this.config;
        (0, redis_smq_common_1.createClientInstance)(redis, (err, client) => {
            if (err)
                cb(err);
            else if (!client)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else {
                const handler = this.createMessageHandlerInstance(client, handlerParams);
                handler.run(cb);
            }
        });
    }
    shutdownMessageHandler(messageHandler, cb) {
        const queue = messageHandler.getQueue();
        messageHandler.shutdown(() => {
            this.messageHandlerInstances = this.messageHandlerInstances.filter((handler) => {
                const q = handler.getQueue();
                return !(q.name === queue.name && q.ns === queue.ns);
            });
            cb();
        });
    }
    getSharedRedisClient() {
        if (!this.sharedRedisClient) {
            throw new redis_smq_common_1.errors.PanicError('Expected a non-empty value');
        }
        return this.sharedRedisClient;
    }
    run(redisClient, cb) {
        this.sharedRedisClient = redisClient;
        redis_smq_common_1.async.each(this.messageHandlers, (handlerParams, _, done) => {
            this.runMessageHandler(handlerParams, done);
        }, cb);
    }
    shutdown(cb) {
        redis_smq_common_1.async.each(this.messageHandlerInstances, (handler, queue, done) => {
            this.shutdownMessageHandler(handler, done);
        }, (err) => {
            if (err)
                cb(err);
            else {
                this.sharedRedisClient = null;
                cb();
            }
        });
    }
    removeMessageHandler(queue, cb) {
        const handler = this.getMessageHandler(queue);
        if (!handler)
            cb();
        else {
            this.messageHandlers = this.messageHandlers.filter((handler) => {
                const q = handler.queue;
                return !(q.name === queue.name && q.ns === queue.ns);
            });
            this.logger.info(`Message handler with parameters (${JSON.stringify(queue)}) has been removed.`);
            const handlerInstance = this.getMessageHandlerInstance(queue);
            if (handlerInstance)
                this.shutdownMessageHandler(handlerInstance, cb);
            else
                cb();
        }
    }
    addMessageHandler(queue, messageHandler, cb) {
        const handler = this.getMessageHandler(queue);
        if (handler)
            cb(new message_handler_already_exists_error_1.MessageHandlerAlreadyExistsError(queue));
        else {
            const handlerParams = {
                queue,
                messageHandler,
            };
            this.messageHandlers.push(handlerParams);
            this.logger.info(`Message handler with parameters (${JSON.stringify(handlerParams)}) has been registered.`);
            if (this.consumer.isRunning())
                this.runMessageHandler(handlerParams, cb);
            else
                cb();
        }
    }
    getQueues() {
        return this.messageHandlers.map((i) => i.queue);
    }
}
exports.MessageHandlerRunner = MessageHandlerRunner;
//# sourceMappingURL=message-handler-runner.js.map