"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Consumer = void 0;
const events_1 = require("../../common/events/events");
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const consumer_heartbeat_1 = require("./consumer-heartbeat");
const base_1 = require("../base");
const consumer_queues_1 = require("./consumer-queues");
const message_handler_runner_1 = require("./consumer-message-handler/message-handler-runner");
const multiplexed_message_handler_runner_1 = require("./consumer-message-handler/multiplexed-message-handler/multiplexed-message-handler-runner");
const queue_1 = require("../queue-manager/queue");
const redis_smq_common_1 = require("redis-smq-common");
const delay_worker_1 = require("../../workers/delay.worker");
const watchdog_worker_1 = require("../../workers/watchdog.worker");
const requeue_worker_1 = require("../../workers/requeue.worker");
const schedule_worker_1 = require("../../workers/schedule.worker");
class Consumer extends base_1.Base {
    constructor(config = {}, useMultiplexing = false) {
        super(config);
        this.heartbeat = null;
        this.workerRunner = null;
        this.setUpHeartbeat = (cb) => {
            (0, redis_smq_common_1.createClientInstance)(this.config.redis, (err, redisClient) => {
                if (err)
                    cb(err);
                else if (!redisClient)
                    cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
                else {
                    this.heartbeat = new consumer_heartbeat_1.ConsumerHeartbeat(this, redisClient);
                    this.heartbeat.on(events_1.events.ERROR, (err) => this.emit(events_1.events.ERROR, err));
                    this.heartbeat.once(events_1.events.TICK, () => cb());
                }
            });
        };
        this.tearDownHeartbeat = (cb) => {
            if (this.heartbeat) {
                this.heartbeat.quit(() => {
                    this.heartbeat = null;
                    cb();
                });
            }
            else
                cb();
        };
        this.setUpConsumerWorkers = (cb) => {
            const redisClient = this.getSharedRedisClient();
            const { keyLockConsumerWorkersRunner } = this.getRedisKeys();
            const nsLogger = redis_smq_common_1.logger.getNamespacedLogger(this.config.logger, `consumer:${this.id}:worker-runner`);
            this.workerRunner = new redis_smq_common_1.WorkerRunner(redisClient, keyLockConsumerWorkersRunner, new redis_smq_common_1.WorkerPool(), nsLogger);
            this.workerRunner.on(events_1.events.ERROR, (err) => this.emit(events_1.events.ERROR, err));
            this.workerRunner.once(events_1.events.UP, cb);
            this.workerRunner.addWorker(new delay_worker_1.default(redisClient, true));
            this.workerRunner.addWorker(new watchdog_worker_1.default(redisClient, this.config, true, this.logger));
            this.workerRunner.addWorker(new requeue_worker_1.default(redisClient, true));
            this.workerRunner.addWorker(new schedule_worker_1.default(redisClient, true));
            this.workerRunner.run();
        };
        this.initConsumerEventListeners = (cb) => {
            this.registerEventListeners(this.config.eventListeners.consumerEventListeners, cb);
        };
        this.tearDownConsumerWorkers = (cb) => {
            if (this.workerRunner) {
                this.workerRunner.quit(() => {
                    this.workerRunner = null;
                    cb();
                });
            }
            else
                cb();
        };
        this.runMessageHandlers = (cb) => {
            const redisClient = this.getSharedRedisClient();
            this.messageHandlerRunner.run(redisClient, cb);
        };
        this.shutdownMessageHandlers = (cb) => {
            if (this.messageHandlerRunner) {
                this.messageHandlerRunner.shutdown(cb);
            }
            else
                cb();
        };
        const nsLogger = redis_smq_common_1.logger.getNamespacedLogger(this.config.logger, `consumer:${this.id}:message-handler`);
        this.messageHandlerRunner = useMultiplexing
            ? new multiplexed_message_handler_runner_1.MultiplexedMessageHandlerRunner(this, nsLogger)
            : new message_handler_runner_1.MessageHandlerRunner(this, nsLogger);
        this.redisKeys = redis_keys_1.redisKeys.getConsumerKeys(this.getId());
    }
    goingUp() {
        return super
            .goingUp()
            .concat([
            this.setUpHeartbeat,
            this.initConsumerEventListeners,
            this.runMessageHandlers,
            this.setUpConsumerWorkers,
        ]);
    }
    goingDown() {
        return [
            this.tearDownConsumerWorkers,
            this.shutdownMessageHandlers,
            this.tearDownHeartbeat,
        ].concat(super.goingDown());
    }
    consume(queue, messageHandler, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        this.messageHandlerRunner.addMessageHandler(queueParams, messageHandler, cb);
    }
    cancel(queue, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        this.messageHandlerRunner.removeMessageHandler(queueParams, cb);
    }
    getQueues() {
        return this.messageHandlerRunner.getQueues();
    }
    getRedisKeys() {
        return this.redisKeys;
    }
    static getOnlineConsumers(redisClient, queue, transform = false, cb) {
        consumer_queues_1.consumerQueues.getQueueConsumers(redisClient, queue, transform, cb);
    }
    static getOnlineConsumerIds(redisClient, queue, cb) {
        consumer_queues_1.consumerQueues.getQueueConsumerIds(redisClient, queue, cb);
    }
    static countOnlineConsumers(redisClient, queue, cb) {
        consumer_queues_1.consumerQueues.countQueueConsumers(redisClient, queue, cb);
    }
    static getConsumerHeartbeats(redisClient, cb) {
        consumer_heartbeat_1.ConsumerHeartbeat.getValidHeartbeats(redisClient, cb);
    }
}
exports.Consumer = Consumer;
//# sourceMappingURL=consumer.js.map