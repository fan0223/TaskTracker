"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingPriorityMessages = void 0;
const queue_1 = require("../queue-manager/queue");
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const sorted_set_1 = require("./message-storage/sorted-set");
class PendingPriorityMessages extends sorted_set_1.SortedSet {
    delete(queue, messageId, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        const { keyQueuePendingPriorityMessageWeight, keyQueuePendingPriorityMessages, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        this.deleteMessage({
            keyMessages: keyQueuePendingPriorityMessages,
            keyMessagesWeight: keyQueuePendingPriorityMessageWeight,
        }, { messageId }, (err) => {
            if (err)
                cb(err);
            else {
                this.logger.info(`Pending message with priority (ID ${messageId}) has been deleted`);
                cb();
            }
        });
    }
    purge(queue, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        const { keyQueuePendingPriorityMessageWeight, keyQueuePendingPriorityMessages, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        this.purgeMessages({
            keyMessages: keyQueuePendingPriorityMessages,
            keyMessagesWeight: keyQueuePendingPriorityMessageWeight,
        }, (err) => {
            if (err)
                cb(err);
            else {
                this.logger.info(`Priority messages from queue (${JSON.stringify(queue)}) have been deleted`);
                cb();
            }
        });
    }
    list(queue, skip, take, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        const { keyQueuePendingPriorityMessageWeight, keyQueuePendingPriorityMessages, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        this.fetchMessages({
            keyMessages: keyQueuePendingPriorityMessages,
            keyMessagesWeight: keyQueuePendingPriorityMessageWeight,
        }, skip, take, cb);
    }
    static count(redisClient, queue, cb) {
        const { keyQueuePendingPriorityMessageWeight } = redis_keys_1.redisKeys.getQueueKeys(queue);
        redisClient.zcard(keyQueuePendingPriorityMessageWeight, (err, reply) => {
            if (err)
                cb(err);
            else
                cb(null, reply !== null && reply !== void 0 ? reply : 0);
        });
    }
    count(queue, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        const { keyQueuePendingPriorityMessageWeight, keyQueuePendingPriorityMessages, } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        this.countMessages({
            keyMessages: keyQueuePendingPriorityMessages,
            keyMessagesWeight: keyQueuePendingPriorityMessageWeight,
        }, cb);
    }
}
exports.PendingPriorityMessages = PendingPriorityMessages;
//# sourceMappingURL=pending-priority-messages.js.map