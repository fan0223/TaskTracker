"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortedSet = void 0;
const abstract_message_storage_1 = require("./abstract-message-storage");
const message_1 = require("../../message/message");
const redis_smq_common_1 = require("redis-smq-common");
const message_not_found_error_1 = require("../errors/message-not-found.error");
class SortedSet extends abstract_message_storage_1.AbstractMessageStorage {
    deleteMessage(key, id, cb) {
        const { keyMessages, keyMessagesWeight } = key;
        const { messageId } = id;
        const multi = this.redisClient.multi();
        multi.hdel(keyMessages, messageId);
        multi.zrem(keyMessagesWeight, messageId);
        multi.exec((err) => cb(err));
    }
    fetchMessages(key, skip, take, cb) {
        this.validatePaginationParams(skip, take);
        const { keyMessages, keyMessagesWeight } = key;
        const getMessages = (reply, cb) => {
            if (!reply.total || !reply.items.length)
                cb(null, { total: reply.total, items: [] });
            else {
                this.redisClient.hmget(keyMessages, reply.items, (err, msg) => {
                    if (err)
                        cb(err);
                    else {
                        const items = [];
                        redis_smq_common_1.async.each(msg !== null && msg !== void 0 ? msg : [], (item, index, done) => {
                            if (!item)
                                done(new redis_smq_common_1.errors.EmptyCallbackReplyError());
                            else {
                                items.push({
                                    sequenceId: skip + Number(index),
                                    message: message_1.Message.createFromMessage(item),
                                });
                                done();
                            }
                        }, (err) => {
                            if (err)
                                cb(err);
                            else {
                                cb(null, {
                                    total: reply.total,
                                    items,
                                });
                            }
                        });
                    }
                });
            }
        };
        const getMessageIds = (total, cb) => {
            if (!total)
                cb(null, { total, items: [] });
            else {
                this.redisClient.zrange(keyMessagesWeight, skip, skip + take - 1, (err, items) => {
                    if (err)
                        cb(err);
                    else
                        cb(null, { total, items: items !== null && items !== void 0 ? items : [] });
                });
            }
        };
        redis_smq_common_1.async.waterfall([
            (cb) => this.countMessages(key, cb),
            getMessageIds,
            getMessages,
        ], cb);
    }
    purgeMessages(key, cb) {
        const { keyMessages, keyMessagesWeight } = key;
        const multi = this.redisClient.multi();
        multi.del(keyMessages);
        multi.del(keyMessagesWeight);
        multi.exec((err) => cb(err));
    }
    getMessageById(key, id, cb) {
        const { keyMessages } = key;
        const { messageId } = id;
        this.redisClient.hget(keyMessages, messageId, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply)
                cb(new message_not_found_error_1.MessageNotFoundError());
            else
                cb(null, message_1.Message.createFromMessage(reply));
        });
    }
    countMessages(key, cb) {
        const { keyMessagesWeight } = key;
        this.redisClient.zcard(keyMessagesWeight, (err, reply) => {
            if (err)
                cb(err);
            else
                cb(null, reply !== null && reply !== void 0 ? reply : 0);
        });
    }
}
exports.SortedSet = SortedSet;
//# sourceMappingURL=sorted-set.js.map