"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.List = void 0;
const abstract_message_storage_1 = require("./abstract-message-storage");
const message_1 = require("../../message/message");
const redis_smq_common_1 = require("redis-smq-common");
const message_not_found_error_1 = require("../errors/message-not-found.error");
const redis_keys_1 = require("../../../common/redis-keys/redis-keys");
const message_requeue_error_1 = require("../errors/message-requeue.error");
const redis_client_1 = require("../../../common/redis-client/redis-client");
class List extends abstract_message_storage_1.AbstractMessageStorage {
    getMessageById(key, id, cb) {
        const { keyMessages } = key;
        const { messageId, sequenceId } = id;
        this.redisClient.lrange(keyMessages, sequenceId, sequenceId, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply || !reply.length)
                cb(new message_not_found_error_1.MessageNotFoundError());
            else {
                const [msg] = reply;
                const message = message_1.Message.createFromMessage(msg);
                if (message.getRequiredId() !== messageId)
                    cb(new message_not_found_error_1.MessageNotFoundError());
                else
                    cb(null, message);
            }
        });
    }
    requeueMessage(key, id, cb) {
        this.getMessageById(key, id, (err, msg) => {
            var _a;
            if (err)
                cb(err);
            else if (!msg)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else {
                const { keyMessages } = key;
                const message = message_1.Message.createFromMessage(msg, false);
                const queue = message.getRequiredQueue();
                message.getRequiredMetadata().reset();
                const { keyQueueSettings, keyQueueSettingsPriorityQueuing, keyQueuePending, keyQueuePendingPriorityMessageWeight, keyQueuePendingPriorityMessages, } = redis_keys_1.redisKeys.getQueueKeys(queue);
                this.redisClient.runScript(redis_client_1.ELuaScriptName.REQUEUE_MESSAGE, [
                    keyQueueSettings,
                    keyQueueSettingsPriorityQueuing,
                    keyQueuePendingPriorityMessages,
                    keyQueuePendingPriorityMessageWeight,
                    keyQueuePending,
                    keyMessages,
                ], [
                    message.getRequiredId(),
                    JSON.stringify(message),
                    (_a = message.getPriority()) !== null && _a !== void 0 ? _a : '',
                    JSON.stringify(msg),
                ], (err, reply) => {
                    if (err)
                        cb(err);
                    else if (!reply)
                        cb(new message_requeue_error_1.MessageRequeueError());
                    else
                        cb();
                });
            }
        });
    }
    deleteMessage(key, id, cb) {
        this.getMessageById(key, id, (err, message) => {
            if (err)
                cb(err);
            else if (!message)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else {
                const { keyMessages } = key;
                this.redisClient.lrem(keyMessages, 1, message.toString(), (err) => cb(err));
            }
        });
    }
    fetchMessages(key, skip, take, cb) {
        this.validatePaginationParams(skip, take);
        const { keyMessages } = key;
        const getItems = (total, cb) => {
            if (!total) {
                cb(null, {
                    total,
                    items: [],
                });
            }
            else
                this.redisClient.lrange(keyMessages, skip, skip + take - 1, (err, result) => {
                    if (err)
                        cb(err);
                    else {
                        const items = (result !== null && result !== void 0 ? result : []).map((msg, index) => {
                            const message = message_1.Message.createFromMessage(msg);
                            return {
                                sequenceId: skip + index,
                                message,
                            };
                        });
                        cb(null, { total, items });
                    }
                });
        };
        redis_smq_common_1.async.waterfall([(cb) => this.countMessages(key, cb), getItems], cb);
    }
    purgeMessages(key, cb) {
        const { keyMessages } = key;
        this.redisClient.del(keyMessages, (err) => cb(err));
    }
    countMessages(key, cb) {
        const { keyMessages } = key;
        this.redisClient.llen(keyMessages, (err, reply) => {
            if (err)
                cb(err);
            else
                cb(null, reply !== null && reply !== void 0 ? reply : 0);
        });
    }
}
exports.List = List;
//# sourceMappingURL=list.js.map