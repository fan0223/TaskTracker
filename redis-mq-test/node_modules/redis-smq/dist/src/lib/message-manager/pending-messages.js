"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingMessages = void 0;
const queue_1 = require("../queue-manager/queue");
const pending_priority_messages_1 = require("./pending-priority-messages");
const pending_lifo_messages_1 = require("./pending-lifo-messages");
class PendingMessages {
    constructor(config, redisClient, logger) {
        this.redisClient = redisClient;
        this.config = config;
        this.pendingLifoMessages = new pending_lifo_messages_1.PendingLifoMessages(config, redisClient, logger);
        this.pendingPriorityMessages = new pending_priority_messages_1.PendingPriorityMessages(config, redisClient, logger);
    }
    purge(queue, cb) {
        const queueParams = queue_1.Queue.getParams(this.config, queue);
        queue_1.Queue.getSettings(this.config, this.redisClient, queueParams, (err, settings) => {
            if (err)
                cb(err);
            else if (settings === null || settings === void 0 ? void 0 : settings.priorityQueuing) {
                this.pendingPriorityMessages.purge(queueParams, cb);
            }
            else {
                this.pendingLifoMessages.purge(queueParams, cb);
            }
        });
    }
    list(queue, skip, take, cb) {
        queue_1.Queue.getSettings(this.config, this.redisClient, queue, (err, settings) => {
            if (err)
                cb(err);
            else if (settings === null || settings === void 0 ? void 0 : settings.priorityQueuing) {
                this.pendingPriorityMessages.list(queue, skip, take, cb);
            }
            else {
                this.pendingLifoMessages.list(queue, skip, take, cb);
            }
        });
    }
    delete(queue, messageId, sequenceId, cb) {
        queue_1.Queue.getSettings(this.config, this.redisClient, queue, (err, settings) => {
            if (err)
                cb(err);
            else if (settings === null || settings === void 0 ? void 0 : settings.priorityQueuing) {
                this.pendingPriorityMessages.delete(queue, messageId, cb);
            }
            else {
                this.pendingLifoMessages.delete(queue, messageId, sequenceId, cb);
            }
        });
    }
    count(queue, cb) {
        queue_1.Queue.getSettings(this.config, this.redisClient, queue, (err, settings) => {
            if (err)
                cb(err);
            else if (settings === null || settings === void 0 ? void 0 : settings.priorityQueuing)
                this.pendingPriorityMessages.count(queue, cb);
            else
                this.pendingLifoMessages.count(queue, cb);
        });
    }
}
exports.PendingMessages = PendingMessages;
//# sourceMappingURL=pending-messages.js.map