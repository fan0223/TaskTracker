"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const cron_parser_1 = require("cron-parser");
const message_metadata_1 = require("./message-metadata");
const redis_smq_common_1 = require("redis-smq-common");
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
class Message {
    constructor() {
        this.queue = null;
        this.ttl = 0;
        this.retryThreshold = 3;
        this.retryDelay = 60000;
        this.consumeTimeout = 0;
        this.body = null;
        this.priority = null;
        this.scheduledCron = null;
        this.scheduledDelay = null;
        this.scheduledRepeatPeriod = null;
        this.scheduledRepeat = 0;
        this.metadata = null;
        this.createdAt = Date.now();
        const { consumeTimeout, retryDelay, ttl, retryThreshold } = Message.defaultConsumeOptions;
        this.setConsumeTimeout(consumeTimeout);
        this.setRetryDelay(retryDelay);
        this.setTTL(ttl);
        this.setRetryThreshold(retryThreshold);
    }
    getMetadata() {
        return this.metadata;
    }
    getRequiredMetadata() {
        if (!this.metadata) {
            throw new redis_smq_common_1.errors.PanicError(`Expected an instance of MessageMetadata. Probably the message has not yet been published`);
        }
        return this.metadata;
    }
    getSetMetadata() {
        if (!this.metadata) {
            this.metadata = new message_metadata_1.MessageMetadata();
            if (this.scheduledDelay) {
                this.metadata.setNextScheduledDelay(this.scheduledDelay);
            }
        }
        return this.metadata;
    }
    getPublishedAt() {
        if (this.metadata) {
            return this.metadata.getPublishedAt();
        }
        return null;
    }
    getScheduledAt() {
        if (this.metadata) {
            return this.metadata.getScheduledAt();
        }
        return null;
    }
    getId() {
        if (this.metadata) {
            return this.metadata.getId();
        }
        return null;
    }
    getRequiredId() {
        if (!this.metadata) {
            throw new redis_smq_common_1.errors.PanicError(`Message has not yet been published`);
        }
        return this.metadata.getId();
    }
    getSetExpired() {
        return this.getRequiredMetadata().getSetExpired(this.getTTL(), this.getCreatedAt());
    }
    setScheduledRepeatPeriod(period) {
        const value = Number(period);
        if (isNaN(value) || value < 0) {
            throw new redis_smq_common_1.errors.ArgumentError('Expected a positive integer value in milliseconds');
        }
        this.scheduledRepeatPeriod = value;
        return this;
    }
    setScheduledDelay(delay) {
        const value = Number(delay);
        if (isNaN(value) || value < 0) {
            throw new redis_smq_common_1.errors.ArgumentError('Expected a positive integer value in milliseconds');
        }
        this.scheduledDelay = value;
        return this;
    }
    setScheduledCRON(cron) {
        (0, cron_parser_1.parseExpression)(cron);
        this.scheduledCron = cron;
        return this;
    }
    setScheduledRepeat(repeat) {
        const value = Number(repeat);
        if (isNaN(value) || value < 0) {
            throw new redis_smq_common_1.errors.ArgumentError('Expected a positive integer value >= 0');
        }
        this.scheduledRepeat = value;
        return this;
    }
    setTTL(ttl) {
        this.ttl = Message.validateTTL(ttl);
        return this;
    }
    setConsumeTimeout(timeout) {
        this.consumeTimeout = Message.validateConsumeTimeout(timeout);
        return this;
    }
    setRetryThreshold(threshold) {
        this.retryThreshold = Message.validateRetryThreshold(threshold);
        return this;
    }
    setRetryDelay(delay) {
        this.retryDelay = Message.validateRetryDelay(delay);
        return this;
    }
    setBody(body) {
        this.body = body;
        return this;
    }
    setPriority(priority) {
        if (!Object.values(Message.MessagePriority).includes(priority)) {
            throw new redis_smq_common_1.errors.ArgumentError('Invalid message priority.');
        }
        this.priority = priority;
        return this;
    }
    setQueue(queue) {
        this.queue =
            typeof queue === 'string'
                ? redis_keys_1.redisKeys.validateRedisKey(queue)
                : {
                    name: redis_keys_1.redisKeys.validateRedisKey(queue.name),
                    ns: redis_keys_1.redisKeys.validateNamespace(queue.ns),
                };
        return this;
    }
    disablePriority() {
        this.priority = null;
        return this;
    }
    hasPriority() {
        return this.priority !== null;
    }
    getQueue() {
        return this.queue;
    }
    getRequiredQueue() {
        if (!this.queue) {
            throw new redis_smq_common_1.errors.PanicError(`Expected queue parameters to be not empty`);
        }
        if (typeof this.queue === 'string') {
            throw new redis_smq_common_1.errors.PanicError(`Expected queue parameters to be not a string`);
        }
        return this.queue;
    }
    getPriority() {
        return this.priority;
    }
    getBody() {
        return this.body;
    }
    getTTL() {
        return this.ttl;
    }
    getRetryThreshold() {
        return this.retryThreshold;
    }
    getRetryDelay() {
        return this.retryDelay;
    }
    getConsumeTimeout() {
        return this.consumeTimeout;
    }
    getCreatedAt() {
        return this.createdAt;
    }
    getScheduledRepeat() {
        return this.scheduledRepeat;
    }
    getScheduledRepeatPeriod() {
        return this.scheduledRepeatPeriod;
    }
    getScheduledCRON() {
        return this.scheduledCron;
    }
    getMessageScheduledDelay() {
        return this.scheduledDelay;
    }
    hasNextDelay() {
        if (this.metadata) {
            return this.metadata.hasDelay();
        }
        return !!this.getMessageScheduledDelay();
    }
    getNextScheduledTimestamp() {
        if (this.isSchedulable()) {
            const metadata = this.getRequiredMetadata();
            const delay = metadata.getSetNextDelay();
            if (delay) {
                return Date.now() + delay;
            }
            const msgScheduledCron = this.getScheduledCRON();
            const cronTimestamp = msgScheduledCron
                ? (0, cron_parser_1.parseExpression)(msgScheduledCron).next().getTime()
                : 0;
            const msgScheduledRepeat = this.getScheduledRepeat();
            let repeatTimestamp = 0;
            if (msgScheduledRepeat) {
                const newCount = metadata.getMessageScheduledRepeatCount() + 1;
                if (newCount <= msgScheduledRepeat) {
                    const scheduledRepeatPeriod = this.getScheduledRepeatPeriod();
                    const now = Date.now();
                    if (scheduledRepeatPeriod) {
                        repeatTimestamp = now + scheduledRepeatPeriod;
                    }
                    else {
                        repeatTimestamp = now;
                    }
                }
            }
            if (repeatTimestamp && cronTimestamp) {
                if (repeatTimestamp < cronTimestamp &&
                    metadata.hasScheduledCronFired()) {
                    metadata.incrMessageScheduledRepeatCount();
                    return repeatTimestamp;
                }
            }
            if (cronTimestamp) {
                metadata.resetMessageScheduledRepeatCount();
                metadata.setMessageScheduledCronFired(true);
                return cronTimestamp;
            }
            if (repeatTimestamp) {
                metadata.incrMessageScheduledRepeatCount();
                return repeatTimestamp;
            }
        }
        return 0;
    }
    toString() {
        return JSON.stringify(this);
    }
    toJSON() {
        return {
            createdAt: this.createdAt,
            queue: typeof this.queue === 'string' ? null : this.queue,
            ttl: this.ttl,
            retryThreshold: this.retryThreshold,
            retryDelay: this.retryDelay,
            consumeTimeout: this.consumeTimeout,
            body: this.body,
            priority: this.priority,
            scheduledCron: this.scheduledCron,
            scheduledDelay: this.scheduledDelay,
            scheduledRepeatPeriod: this.scheduledRepeatPeriod,
            scheduledRepeat: this.scheduledRepeat,
            metadata: this.metadata ? this.metadata.toJSON() : null,
        };
    }
    hasRetryThresholdExceeded() {
        const metadata = this.getMetadata();
        if (!metadata) {
            return false;
        }
        const threshold = this.getRetryThreshold();
        return metadata.getAttempts() + 1 >= threshold;
    }
    isSchedulable() {
        return this.hasNextDelay() || this.isPeriodic();
    }
    isPeriodic() {
        return this.getScheduledCRON() !== null || this.getScheduledRepeat() > 0;
    }
    static validateRetryDelay(delay) {
        const value = Number(delay);
        if (isNaN(value) || value < 0) {
            throw new redis_smq_common_1.errors.ArgumentError('Expected a positive integer in milliseconds >= 0');
        }
        return value;
    }
    static validateTTL(ttl) {
        const value = Number(ttl);
        if (isNaN(value) || value < 0) {
            throw new redis_smq_common_1.errors.ArgumentError('Expected a positive integer value in milliseconds >= 0');
        }
        return value;
    }
    static validateConsumeTimeout(timeout) {
        const value = Number(timeout);
        if (isNaN(value) || value < 0) {
            throw new redis_smq_common_1.errors.ArgumentError('Expected a positive integer value in milliseconds >= 0');
        }
        return value;
    }
    static validateRetryThreshold(threshold) {
        const value = Number(threshold);
        if (isNaN(value) || value < 0) {
            throw new redis_smq_common_1.errors.ArgumentError('Retry threshold should be a positive integer >= 0');
        }
        return value;
    }
    static createFromMessage(message, reset = false) {
        const messageJSON = typeof message === 'string' ? JSON.parse(message) : message;
        const m = new Message();
        Object.assign(m, messageJSON, {
            metadata: messageJSON.metadata
                ? Object.assign(new message_metadata_1.MessageMetadata(), messageJSON.metadata)
                : null,
        });
        if (reset) {
            const metadata = m.getMetadata();
            if (metadata) {
                metadata.reset();
            }
        }
        return m;
    }
    static setDefaultConsumeOptions(consumeOptions) {
        const { ttl = null, retryThreshold = null, retryDelay = null, consumeTimeout = null, } = consumeOptions;
        if (ttl !== null)
            Message.defaultConsumeOptions.ttl = Message.validateTTL(ttl);
        if (retryDelay !== null)
            Message.defaultConsumeOptions.retryDelay =
                Message.validateRetryDelay(retryDelay);
        if (retryThreshold !== null)
            Message.defaultConsumeOptions.retryThreshold =
                Message.validateRetryThreshold(retryThreshold);
        if (consumeTimeout !== null)
            Message.defaultConsumeOptions.consumeTimeout =
                Message.validateConsumeTimeout(consumeTimeout);
    }
}
exports.Message = Message;
Message.MessagePriority = {
    LOWEST: 7,
    VERY_LOW: 6,
    LOW: 5,
    NORMAL: 4,
    ABOVE_NORMAL: 3,
    HIGH: 2,
    VERY_HIGH: 1,
    HIGHEST: 0,
};
Message.defaultConsumeOptions = {
    ttl: 0,
    retryThreshold: 3,
    retryDelay: 60000,
    consumeTimeout: 0,
};
//# sourceMappingURL=message.js.map