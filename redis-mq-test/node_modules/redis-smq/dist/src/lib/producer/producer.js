"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Producer = void 0;
const events_1 = require("../../common/events/events");
const base_1 = require("../base");
const redis_smq_common_1 = require("redis-smq-common");
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const message_not_published_error_1 = require("./errors/message-not-published.error");
const message_queue_required_error_1 = require("./errors/message-queue-required.error");
const message_already_published_error_1 = require("./errors/message-already-published.error");
const redis_client_1 = require("../../common/redis-client/redis-client");
const schedule_message_1 = require("./schedule-message");
const queue_1 = require("../queue-manager/queue");
const event_provider_1 = require("../../common/event-listeners/event-provider");
class Producer extends base_1.Base {
    constructor(config = {}) {
        super(config);
        this.eventListeners = [];
        this.initEventListeners = (cb) => {
            const sharedRedisClient = this.getSharedRedisClient();
            this.config.eventListeners.producerEventListeners.forEach((ctor) => this.eventListeners.push(new ctor(sharedRedisClient, this.id, new event_provider_1.EventProvider(this))));
            cb();
        };
        this.run();
    }
    goingUp() {
        return super.goingUp().concat([this.initEventListeners]);
    }
    goingDown() {
        return [
            (cb) => redis_smq_common_1.async.each(this.eventListeners, (listener, idx, done) => listener.quit(done), (err) => {
                if (err)
                    cb(err);
                else {
                    this.eventListeners = [];
                    cb();
                }
            }),
        ].concat(super.goingDown());
    }
    enqueue(redisClient, message, cb) {
        var _a;
        const queue = message.getRequiredQueue();
        message.getRequiredMetadata().setPublishedAt(Date.now());
        const { keyQueueSettings, keyQueueSettingsPriorityQueuing, keyQueuePendingPriorityMessages, keyQueuePendingPriorityMessageWeight, keyQueuePending, } = redis_keys_1.redisKeys.getQueueKeys(queue);
        redisClient.runScript(redis_client_1.ELuaScriptName.PUBLISH_MESSAGE, [
            keyQueueSettings,
            keyQueueSettingsPriorityQueuing,
            keyQueuePendingPriorityMessages,
            keyQueuePendingPriorityMessageWeight,
            keyQueuePending,
        ], [
            message.getRequiredId(),
            JSON.stringify(message),
            (_a = message.getPriority()) !== null && _a !== void 0 ? _a : '',
        ], (err, reply) => {
            if (err)
                cb(err);
            else if (reply !== 'OK')
                cb(new message_not_published_error_1.MessageNotPublishedError(String(reply)));
            else
                cb();
        });
    }
    produce(message, cb) {
        const queue = message.getQueue();
        if (!queue) {
            cb(new message_queue_required_error_1.MessageQueueRequiredError());
        }
        else if (message.getMetadata()) {
            cb(new message_already_published_error_1.MessageAlreadyPublishedError());
        }
        else {
            const queueParams = queue_1.Queue.getParams(this.config, queue);
            message.setQueue(queueParams);
            const messageId = message.getSetMetadata().getId();
            const callback = (err) => {
                if (err)
                    cb(err);
                else {
                    this.emit(events_1.events.MESSAGE_PUBLISHED, message);
                    cb();
                }
            };
            const proceed = () => {
                const redisClient = this.getSharedRedisClient();
                if (message.isSchedulable()) {
                    (0, schedule_message_1.scheduleMessage)(redisClient, message, (err) => {
                        if (err)
                            callback(err);
                        else {
                            this.logger.info(`Message (ID ${messageId}) has been scheduled.`);
                            callback();
                        }
                    });
                }
                else {
                    this.enqueue(redisClient, message, (err) => {
                        if (err)
                            callback(err);
                        else {
                            this.logger.info(`Message (ID ${messageId}) has been published.`);
                            callback();
                        }
                    });
                }
            };
            if (!this.powerManager.isUp()) {
                if (this.powerManager.isGoingUp()) {
                    this.once(events_1.events.UP, proceed);
                }
                else {
                    cb(new redis_smq_common_1.errors.PanicError(`Producer ID ${this.getId()} is not running`));
                }
            }
            else
                proceed();
        }
    }
}
exports.Producer = Producer;
//# sourceMappingURL=producer.js.map