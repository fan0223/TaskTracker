"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Producer = void 0;
const events_1 = require("../../common/events/events");
const base_1 = require("../base");
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const message_not_published_error_1 = require("./errors/message-not-published.error");
const message_queue_required_error_1 = require("./errors/message-queue-required.error");
const message_already_published_error_1 = require("./errors/message-already-published.error");
const redis_client_1 = require("../../common/redis-client/redis-client");
const schedule_message_1 = require("./schedule-message");
const queue_1 = require("../queue-manager/queue");
const producer_not_running_error_1 = require("./errors/producer-not-running.error");
class Producer extends base_1.Base {
    constructor() {
        super(...arguments);
        this.initProducerEventListeners = (cb) => {
            this.registerEventListeners(this.config.eventListeners.producerEventListeners, cb);
        };
    }
    goingUp() {
        return super.goingUp().concat([this.initProducerEventListeners]);
    }
    enqueue(redisClient, message, cb) {
        var _a;
        const queue = message.getRequiredQueue();
        message.getRequiredMetadata().setPublishedAt(Date.now());
        const { keyQueueSettings, keyQueueSettingsPriorityQueuing, keyQueuePendingPriorityMessages, keyQueuePendingPriorityMessageWeight, keyQueuePending, } = redis_keys_1.redisKeys.getQueueKeys(queue);
        redisClient.runScript(redis_client_1.ELuaScriptName.PUBLISH_MESSAGE, [
            keyQueueSettings,
            keyQueueSettingsPriorityQueuing,
            keyQueuePendingPriorityMessages,
            keyQueuePendingPriorityMessageWeight,
            keyQueuePending,
        ], [
            message.getRequiredId(),
            JSON.stringify(message),
            (_a = message.getPriority()) !== null && _a !== void 0 ? _a : '',
        ], (err, reply) => {
            if (err)
                cb(err);
            else if (reply !== 'OK')
                cb(new message_not_published_error_1.MessageNotPublishedError(String(reply)));
            else
                cb();
        });
    }
    produce(message, cb) {
        const queue = message.getQueue();
        if (!queue) {
            cb(new message_queue_required_error_1.MessageQueueRequiredError());
        }
        else if (message.getMetadata()) {
            cb(new message_already_published_error_1.MessageAlreadyPublishedError());
        }
        else {
            if (!this.powerManager.isUp())
                cb(new producer_not_running_error_1.ProducerNotRunningError());
            else {
                const queueParams = queue_1.Queue.getParams(this.config, queue);
                message.setQueue(queueParams);
                const messageId = message.getSetMetadata().getId();
                const callback = (err) => {
                    if (err)
                        cb(err);
                    else {
                        this.emit(events_1.events.MESSAGE_PUBLISHED, message);
                        cb();
                    }
                };
                const redisClient = this.getSharedRedisClient();
                if (message.isSchedulable()) {
                    (0, schedule_message_1.scheduleMessage)(redisClient, message, (err) => {
                        if (err)
                            callback(err);
                        else {
                            this.logger.info(`Message (ID ${messageId}) has been scheduled.`);
                            callback();
                        }
                    });
                }
                else {
                    this.enqueue(redisClient, message, (err) => {
                        if (err)
                            callback(err);
                        else {
                            this.logger.info(`Message (ID ${messageId}) has been published.`);
                            callback();
                        }
                    });
                }
            }
        }
    }
}
exports.Producer = Producer;
//# sourceMappingURL=producer.js.map