"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ticker = void 0;
const events_1 = require("events");
const events_2 = require("../events/events");
const power_manager_1 = require("../power-manager/power-manager");
const ticker_error_1 = require("./ticker.error");
const panic_error_1 = require("../errors/panic.error");
class Ticker extends events_1.EventEmitter {
    constructor(onTickFn = () => void 0, time = 1000) {
        super();
        this.powerManager = new power_manager_1.PowerManager();
        this.onNextTickFn = null;
        this.timeout = null;
        this.interval = null;
        this.shutdownTimeout = null;
        this.aborted = false;
        this.onTickFn = onTickFn;
        this.time = time;
        this.powerManager.goingUp();
    }
    shutdown() {
        if (this.shutdownTimeout) {
            clearTimeout(this.shutdownTimeout);
        }
        this.powerManager.commit();
        this.emit(events_2.events.DOWN);
    }
    onTick() {
        var _a;
        if (this.powerManager.isGoingDown()) {
            this.shutdown();
        }
        else if (this.powerManager.isRunning()) {
            const tickFn = (_a = this.onNextTickFn) !== null && _a !== void 0 ? _a : this.onTickFn;
            this.onNextTickFn = null;
            tickFn();
        }
        else {
            this.emit(events_2.events.ERROR, new panic_error_1.PanicError(`Unexpected call`));
        }
    }
    abort() {
        if (!this.aborted) {
            this.aborted = true;
            if (this.powerManager.isGoingDown())
                this.shutdown();
            else
                this.quit();
        }
    }
    quit() {
        if (this.powerManager.isGoingUp()) {
            this.powerManager.rollback();
            this.emit(events_2.events.DOWN);
        }
        else if (this.aborted && this.powerManager.isDown()) {
            this.emit(events_2.events.DOWN);
        }
        else {
            this.powerManager.goingDown();
            if (this.timeout) {
                clearTimeout(this.timeout);
                this.shutdown();
            }
            else if (this.interval) {
                clearInterval(this.interval);
                this.shutdown();
            }
            else if (this.aborted) {
                this.shutdown();
            }
            else {
                this.shutdownTimeout = setTimeout(() => {
                    if (this.powerManager.isGoingDown()) {
                        this.shutdown();
                    }
                }, 60000);
            }
        }
    }
    isTicking() {
        return !!(this.timeout || this.interval);
    }
    nextTick() {
        if (this.isTicking()) {
            throw new ticker_error_1.TickerError('A timer is already running');
        }
        if (this.powerManager.isGoingDown()) {
            this.shutdown();
        }
        else {
            if (this.powerManager.isGoingUp()) {
                this.powerManager.commit();
            }
            if (this.powerManager.isRunning()) {
                this.timeout = setTimeout(() => {
                    this.timeout = null;
                    this.onTick();
                }, this.time);
            }
        }
    }
    nextTickFn(fn) {
        this.onNextTickFn = fn;
        this.nextTick();
    }
    runTimer() {
        if (this.isTicking()) {
            throw new ticker_error_1.TickerError('A timer is already running');
        }
        if (this.powerManager.isGoingUp()) {
            this.powerManager.commit();
        }
        if (this.powerManager.isRunning()) {
            this.interval = setInterval(() => this.onTick(), this.time);
        }
    }
}
exports.Ticker = Ticker;
//# sourceMappingURL=ticker.js.map