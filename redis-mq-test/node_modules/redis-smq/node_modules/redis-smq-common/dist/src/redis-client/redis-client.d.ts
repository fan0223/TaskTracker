/// <reference types="node" />
import { EventEmitter } from 'events';
import { LuaScripts } from './lua-scripts';
import { ICallback, IRedisClientMulti } from '../../types';
export declare enum ELuaScriptName {
    LPOPRPUSH = "LPOPRPUSH",
    ZPOPHGETRPUSH = "ZPOPHGETRPUSH",
    LPOPRPUSHEXTRA = "LPOPRPUSHEXTRA"
}
export declare abstract class RedisClient extends EventEmitter {
    protected static redisServerVersion: number[] | null;
    protected static scriptsLoaded: boolean;
    protected static luaScripts: LuaScripts;
    protected connectionClosed: boolean;
    protected validateRedisVersion(major: number, feature?: number, minor?: number): boolean;
    abstract set(key: string, value: string, options: {
        expire?: {
            mode: 'EX' | 'PX';
            value: number;
        };
        exists?: 'NX' | 'XX';
    }, cb: ICallback<string | null>): void;
    abstract zadd(key: string, score: number, member: string, cb: ICallback<number | string>): void;
    abstract multi(): IRedisClientMulti;
    abstract watch(args: string[], cb: ICallback<string>): void;
    abstract unwatch(cb: ICallback<string>): void;
    abstract sismember(key: string, member: string, cb: ICallback<number>): void;
    abstract zcard(key: string, cb: ICallback<number>): void;
    abstract zrange(key: string, min: number, max: number, cb: ICallback<string[]>): void;
    abstract psubscribe(pattern: string): void;
    abstract punsubscribe(channel: string): void;
    abstract subscribe(channel: string): void;
    abstract unsubscribe(channel: string): void;
    abstract zrangebyscore(key: string, min: number | string, max: number | string, cb: ICallback<string[]>): void;
    abstract smembers(key: string, cb: ICallback<string[]>): void;
    abstract sadd(key: string, member: string, cb: ICallback<number>): void;
    abstract hgetall(key: string, cb: ICallback<Record<string, string>>): void;
    abstract hget(key: string, field: string, cb: ICallback<string | null>): void;
    abstract hset(key: string, field: string, value: string, cb: ICallback<number>): void;
    abstract hdel(key: string, fields: string | string[], cb: ICallback<number>): void;
    abstract lrange(key: string, start: number, stop: number, cb: ICallback<string[]>): void;
    abstract hkeys(key: string, cb: ICallback<string[]>): void;
    abstract hlen(key: string, cb: ICallback<number>): void;
    abstract brpoplpush(source: string, destination: string, timeout: number, cb: ICallback<string | null>): void;
    abstract rpoplpush(source: string, destination: string, cb: ICallback<string | null>): void;
    zpophgetrpush(source: string, sourceHash: string, destination: string, cb: ICallback<string | null>): void;
    lpoprpushextra(source: string, destination: string, listSize: number, expire: number, cb: ICallback<string | null>): void;
    lpoprpush(source: string, destination: string, cb: ICallback<string | null>): void;
    abstract zrangebyscorewithscores(source: string, min: number, max: number, cb: ICallback<Record<string, string>>): void;
    abstract rpop(key: string, cb: ICallback<string | null>): void;
    abstract lrem(key: string, count: number, element: string, cb: ICallback<number>): void;
    abstract publish(channel: string, message: string, cb: ICallback<number>): void;
    abstract flushall(cb: ICallback<string>): void;
    abstract loadScript(script: string, cb: ICallback<string>): void;
    abstract evalsha(hash: string, args: (string | number)[] | string | number, cb: (err?: Error | null, res?: unknown) => void): void;
    abstract get(key: string, cb: ICallback<string | null>): void;
    abstract del(key: string | string[], cb: ICallback<number>): void;
    abstract llen(key: string, cb: ICallback<number>): void;
    abstract lmove(source: string, destination: string, from: 'LEFT' | 'RIGHT', to: 'LEFT' | 'RIGHT', cb: ICallback<string | null>): void;
    abstract zremrangebyscore(source: string, min: number | string, max: number | string, cb: ICallback<number>): void;
    abstract hmget(source: string, keys: string[], cb: ICallback<(string | null)[]>): void;
    abstract halt(cb: ICallback<void>): void;
    abstract end(flush: boolean): void;
    abstract quit(cb: ICallback<void>): void;
    abstract getInfo(cb: ICallback<string>): void;
    updateServerVersion(cb: ICallback<void>): void;
    loadScripts(cb: ICallback<void>): void;
    runScript(scriptName: string, keys: string[], args: (string | number)[], cb: ICallback<unknown>): void;
    static addScript(name: string, content: string): void;
}
