"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IoredisClient = void 0;
const redis_client_1 = require("../redis-client");
const redis_client_error_1 = require("../errors/redis-client.error");
const IORedis = require("ioredis");
const ioredis_client_multi_1 = require("./ioredis-client-multi");
class IoredisClient extends redis_client_1.RedisClient {
    constructor(config = {}) {
        super();
        this.client = new IORedis(config);
        this.client.once('ready', () => {
            this.connectionClosed = false;
            this.emit('ready');
        });
        this.client.once('end', () => {
            this.connectionClosed = true;
            this.emit('end');
        });
    }
    set(key, value, options, cb) {
        if (options.exists && options.expire) {
            this.client.set(key, value, options.expire.mode, options.expire.value, options.exists, cb);
        }
        else if (options.expire) {
            this.client.set(key, value, options.expire.mode, options.expire.value, cb);
        }
        else if (options.exists) {
            this.client.set(key, value, options.exists, cb);
        }
        else {
            this.client.set(key, value, cb);
        }
    }
    zadd(key, score, member, cb) {
        this.client.zadd(key, score, member, cb);
    }
    multi() {
        return new ioredis_client_multi_1.IoredisClientMulti(this.client);
    }
    watch(args, cb) {
        this.client.watch(args, cb);
    }
    unwatch(cb) {
        this.client.unwatch(cb);
    }
    sismember(key, member, cb) {
        this.client.sismember(key, member, cb);
    }
    zcard(key, cb) {
        this.client.zcard(key, cb);
    }
    zrange(key, min, max, cb) {
        this.client.zrange(key, min, max, cb);
    }
    psubscribe(pattern) {
        this.client.psubscribe(pattern);
    }
    punsubscribe(channel) {
        this.client.punsubscribe(channel);
    }
    subscribe(channel) {
        this.client.subscribe(channel);
    }
    unsubscribe(channel) {
        this.client.unsubscribe(channel);
    }
    zrangebyscore(key, min, max, cb) {
        this.client.zrangebyscore(key, min, max, cb);
    }
    smembers(key, cb) {
        this.client.smembers(key, cb);
    }
    sadd(key, member, cb) {
        this.client.sadd(key, member, cb);
    }
    hgetall(key, cb) {
        this.client.hgetall(key, cb);
    }
    hget(key, field, cb) {
        this.client.hget(key, field, cb);
    }
    hset(key, field, value, cb) {
        this.client.hset(key, field, value, cb);
    }
    hdel(key, fields, cb) {
        this.client.hdel(key, fields, cb);
    }
    lrange(key, start, stop, cb) {
        this.client.lrange(key, start, stop, cb);
    }
    hkeys(key, cb) {
        this.client.hkeys(key, cb);
    }
    hlen(key, cb) {
        this.client.hlen(key, cb);
    }
    brpoplpush(source, destination, timeout, cb) {
        this.client.brpoplpush(source, destination, timeout, cb);
    }
    rpoplpush(source, destination, cb) {
        this.client.rpoplpush(source, destination, cb);
    }
    zrangebyscorewithscores(source, min, max, cb) {
        this.client.zrangebyscore(source, min, max, 'WITHSCORES', (err, reply) => {
            if (err)
                cb(err);
            else {
                const replyRange = reply !== null && reply !== void 0 ? reply : [];
                const range = {};
                for (let slice = replyRange.splice(0, 2); slice.length > 0; slice = replyRange.splice(0, 2)) {
                    const [member, score] = slice;
                    range[score] = member;
                }
                cb(null, range);
            }
        });
    }
    rpop(key, cb) {
        this.client.rpop(key, cb);
    }
    lrem(key, count, element, cb) {
        this.client.lrem(key, count, element, cb);
    }
    publish(channel, message, cb) {
        this.client.publish(channel, message, cb);
    }
    flushall(cb) {
        this.client.flushall(cb);
    }
    loadScript(script, cb) {
        this.client.script('load', script, cb);
    }
    evalsha(hash, args, cb) {
        const arrHash = [hash];
        const arrArgs = Array.isArray(args) ? args : [args];
        this.client.evalsha(arrHash.concat(arrArgs), cb);
    }
    get(key, cb) {
        this.client.get(key, cb);
    }
    del(key, cb) {
        this.client.del(key, cb);
    }
    llen(key, cb) {
        this.client.llen(key, cb);
    }
    lmove(source, destination, from, to, cb) {
        if (!this.validateRedisVersion(6, 2)) {
            cb(new redis_client_error_1.RedisClientError('Command not supported by your Redis server. Minimal required Redis server version is 6.2.0.'));
        }
        else {
            this.client.lmove(source, destination, from, to, cb);
        }
    }
    zremrangebyscore(source, min, max, cb) {
        this.client.zremrangebyscore(source, min, max, cb);
    }
    hmget(source, keys, cb) {
        this.client.hmget(source, keys, cb);
    }
    halt(cb) {
        if (!this.connectionClosed) {
            this.client.once('end', cb);
            this.end(true);
        }
        else
            cb();
    }
    end(flush) {
        if (!this.connectionClosed) {
            this.client.disconnect(false);
        }
    }
    quit(cb = () => void 0) {
        if (!this.connectionClosed) {
            this.client.once('end', cb);
            this.client.quit();
        }
        else
            cb();
    }
    getInfo(cb) {
        this.client.info(cb);
    }
    on(event, listener) {
        this.client.on(event, listener);
        return this;
    }
}
exports.IoredisClient = IoredisClient;
//# sourceMappingURL=ioredis-client.js.map