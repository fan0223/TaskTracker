"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeRedisV4Client = void 0;
const redis_client_1 = require("../redis-client");
const redis_client_error_1 = require("../errors/redis-client.error");
const client_1 = require("@redis/client");
const node_redis_v4_client_multi_1 = require("./node-redis-v4-client-multi");
class NodeRedisV4Client extends redis_client_1.RedisClient {
    constructor(config = {}) {
        super();
        this.client = (0, client_1.createClient)(config);
        this.client.once('ready', () => {
            this.connectionClosed = false;
            this.emit('ready');
        });
        this.client.once('end', () => {
            this.connectionClosed = true;
            this.emit('end');
        });
        this.client.connect();
    }
    set(key, value, options, cb) {
        this.client
            .set(key, value, Object.assign(Object.assign({}, (options.expire
            ? { [options.expire.mode]: options.expire.value }
            : {})), (options.exists ? { [options.exists]: true } : {})))
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    zadd(key, score, member, cb) {
        this.client
            .zAdd(key, { score, value: member })
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    multi() {
        return new node_redis_v4_client_multi_1.NodeRedisV4ClientMulti(this.client);
    }
    watch(args, cb) {
        this.client
            .watch(args)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    unwatch(cb) {
        this.client
            .unwatch()
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    sismember(key, member, cb) {
        this.client
            .sIsMember(key, member)
            .then((reply) => cb(null, Number(reply)))
            .catch(cb);
    }
    zcard(key, cb) {
        this.client
            .zCard(key)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    zrange(key, min, max, cb) {
        this.client
            .zRange(key, min, max)
            .then((reply) => cb(null, (Array.isArray(reply) ? reply : []).map((i) => String(i))))
            .catch(cb);
    }
    psubscribe(pattern) {
        this.client.pSubscribe(pattern, (message, channel) => {
            this.client.emit('pmessage', pattern, channel, message);
        });
    }
    punsubscribe(channel) {
        this.client.pUnsubscribe(channel).catch(() => void 0);
    }
    subscribe(channel) {
        this.client.subscribe(channel, (message, channel) => {
            this.client.emit('message', channel, message);
        });
    }
    unsubscribe(channel) {
        this.client.unsubscribe(channel).catch(() => void 0);
    }
    zrangebyscore(key, min, max, cb) {
        this.client
            .zRangeByScore(key, min, max)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    smembers(key, cb) {
        this.client
            .sMembers(key)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    sscan(key, options, cb) {
        const result = new Set();
        const iterate = (position) => {
            const args = [
                key,
                position,
                options,
            ];
            this.client
                .sScan(...args)
                .then(({ cursor, members }) => {
                members.forEach((i) => result.add(i));
                if (cursor === 0)
                    cb(null, [...result]);
                else
                    iterate(cursor);
            })
                .catch(cb);
        };
        iterate(0);
    }
    sadd(key, member, cb) {
        this.client
            .sAdd(key, member)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    srem(key, member, cb) {
        this.client
            .sRem(key, member)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    hgetall(key, cb) {
        this.client
            .hGetAll(key)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    hget(key, field, cb) {
        this.client
            .hGet(key, field)
            .then((reply) => cb(null, reply !== null && reply !== void 0 ? reply : null))
            .catch(cb);
    }
    hset(key, field, value, cb) {
        this.client
            .hSet(key, field, value)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    hdel(key, fields, cb) {
        this.client
            .hDel(key, fields)
            .then((reply) => cb(null, Number(reply)))
            .catch(cb);
    }
    lrange(key, start, stop, cb) {
        this.client
            .lRange(key, start, stop)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    hkeys(key, cb) {
        this.client
            .hKeys(key)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    hlen(key, cb) {
        this.client
            .hLen(key)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    brpoplpush(source, destination, timeout, cb) {
        this.client
            .brPopLPush(source, destination, timeout)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    rpoplpush(source, destination, cb) {
        this.client
            .rPopLPush(source, destination)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    zrangebyscorewithscores(source, min, max, cb) {
        this.client
            .zRangeByScoreWithScores(source, min, max)
            .then((reply) => {
            const range = {};
            for (const { score, value } of reply) {
                range[score] = value;
            }
            cb(null, range);
        })
            .catch(cb);
    }
    rpop(key, cb) {
        this.client
            .rPop(key)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    lrem(key, count, element, cb) {
        this.client
            .lRem(key, count, element)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    publish(channel, message, cb) {
        this.client
            .publish(channel, message)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    flushall(cb) {
        this.client
            .flushAll()
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    loadScript(script, cb) {
        this.client
            .sendCommand(['SCRIPT', 'LOAD', script])
            .then((reply) => cb(null, typeof reply === 'string' ? reply : String(reply)))
            .catch(cb);
    }
    evalsha(hash, args, cb) {
        const arrHash = [hash];
        const arrArgs = Array.isArray(args) ? args : [args];
        this.client
            .sendCommand([
            'evalsha',
            ...arrHash.concat(arrArgs).map((i) => String(i)),
        ])
            .then((reply) => {
            if (Array.isArray(reply)) {
                cb(null, reply.map((i) => (i instanceof Buffer ? i.toString() : i)));
            }
            else if (reply instanceof Buffer)
                cb(null, reply.toString());
            else
                cb(null, reply);
        })
            .catch(cb);
    }
    get(key, cb) {
        this.client
            .sendCommand(['get', key])
            .then((reply) => cb(null, typeof reply === 'string' ? reply : null))
            .catch(cb);
    }
    del(key, cb) {
        this.client
            .del(key)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    llen(key, cb) {
        this.client
            .sendCommand(['llen', key])
            .then((reply) => cb(null, Number(reply)))
            .catch(cb);
    }
    lmove(source, destination, from, to, cb) {
        if (!this.validateRedisVersion(6, 2)) {
            cb(new redis_client_error_1.RedisClientError('Command not supported by your Redis server. Minimal required Redis server version is 6.2.0.'));
        }
        else {
            this.client
                .lMove(source, destination, from, to)
                .then((reply) => cb(null, reply))
                .catch(cb);
        }
    }
    zremrangebyscore(source, min, max, cb) {
        this.client
            .sendCommand(['zremrangebyscore', source, `${min}`, `${max}`])
            .then((reply) => cb(null, Number(reply)))
            .catch(cb);
    }
    hmget(source, keys, cb) {
        this.client
            .hmGet(source, keys)
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    halt(cb) {
        if (!this.connectionClosed) {
            this.client.once('end', cb);
            this.end(true);
        }
        else
            cb();
    }
    end(flush) {
        if (!this.connectionClosed) {
            this.client.disconnect().catch(() => void 0);
        }
    }
    quit(cb = () => void 0) {
        if (!this.connectionClosed) {
            this.client.once('end', cb);
            this.client.quit();
        }
        else
            cb();
    }
    getInfo(cb) {
        this.client
            .info()
            .then((reply) => cb(null, reply))
            .catch(cb);
    }
    on(event, listener) {
        this.client.on(event, listener);
        return this;
    }
}
exports.NodeRedisV4Client = NodeRedisV4Client;
//# sourceMappingURL=node-redis-v4-client.js.map