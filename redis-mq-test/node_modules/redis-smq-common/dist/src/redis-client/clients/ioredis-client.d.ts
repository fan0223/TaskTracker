import { RedisClient } from '../redis-client';
import { Redis, RedisOptions } from 'ioredis';
import { ICallback } from '../../../types';
import { IoredisClientMulti } from './ioredis-client-multi';
export declare class IoredisClient extends RedisClient {
    protected client: Redis;
    constructor(config?: RedisOptions);
    set(key: string, value: string, options: {
        expire?: {
            mode: 'EX' | 'PX';
            value: number;
        };
        exists?: 'NX' | 'XX';
    }, cb: ICallback<string | null>): void;
    zadd(key: string, score: number, member: string, cb: ICallback<number | string>): void;
    multi(): IoredisClientMulti;
    watch(args: string[], cb: ICallback<string>): void;
    unwatch(cb: ICallback<string>): void;
    sismember(key: string, member: string, cb: ICallback<number>): void;
    sscan(key: string, options: {
        MATCH?: string;
        COUNT?: number;
    }, cb: ICallback<string[]>): void;
    zcard(key: string, cb: ICallback<number>): void;
    zrange(key: string, min: number, max: number, cb: ICallback<string[]>): void;
    psubscribe(pattern: string): void;
    punsubscribe(channel: string): void;
    subscribe(channel: string): void;
    unsubscribe(channel: string): void;
    zrangebyscore(key: string, min: number | string, max: number | string, cb: ICallback<string[]>): void;
    smembers(key: string, cb: ICallback<string[]>): void;
    sadd(key: string, member: string, cb: ICallback<number>): void;
    srem(key: string, member: string, cb: ICallback<number>): void;
    hgetall(key: string, cb: ICallback<Record<string, string>>): void;
    hget(key: string, field: string, cb: ICallback<string | null>): void;
    hset(key: string, field: string, value: string, cb: ICallback<number>): void;
    hdel(key: string, fields: string | string[], cb: ICallback<number>): void;
    lrange(key: string, start: number, stop: number, cb: ICallback<string[]>): void;
    hkeys(key: string, cb: ICallback<string[]>): void;
    hlen(key: string, cb: ICallback<number>): void;
    brpoplpush(source: string, destination: string, timeout: number, cb: ICallback<string | null>): void;
    rpoplpush(source: string, destination: string, cb: ICallback<string | null>): void;
    zrangebyscorewithscores(source: string, min: number, max: number, cb: ICallback<Record<string, string>>): void;
    rpop(key: string, cb: ICallback<string | null>): void;
    lrem(key: string, count: number, element: string, cb: ICallback<number>): void;
    publish(channel: string, message: string, cb: ICallback<number>): void;
    flushall(cb: ICallback<string>): void;
    loadScript(script: string, cb: ICallback<string>): void;
    evalsha(hash: string, args: (string | number)[] | string | number, cb: (err?: Error | null, res?: unknown) => void): void;
    get(key: string, cb: ICallback<string | null>): void;
    del(key: string | string[], cb: ICallback<number>): void;
    llen(key: string, cb: ICallback<number>): void;
    lmove(source: string, destination: string, from: 'LEFT' | 'RIGHT', to: 'LEFT' | 'RIGHT', cb: ICallback<string | null>): void;
    zremrangebyscore(source: string, min: number | string, max: number | string, cb: ICallback<number>): void;
    hmget(source: string, keys: string[], cb: ICallback<(string | null)[]>): void;
    halt(cb: ICallback<void>): void;
    end(flush: boolean): void;
    quit(cb?: ICallback<void>): void;
    getInfo(cb: ICallback<string>): void;
    on(event: string, listener: (...args: unknown[]) => any): this;
}
