"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerRunner = void 0;
const power_manager_1 = require("../../power-manager/power-manager");
const events_1 = require("events");
const ticker_1 = require("../../ticker/ticker");
const lock_manager_1 = require("../../lock-manager/lock-manager");
const events_2 = require("../../events/events");
const async_1 = require("../../async/async");
const lock_manager_acquire_error_1 = require("../../lock-manager/errors/lock-manager-acquire.error");
class WorkerRunner extends events_1.EventEmitter {
    constructor(redisClient, keyLock, workerPool, logger) {
        super();
        this.onTick = () => {
            async_1.async.waterfall([
                (cb) => {
                    this.lockManager.acquireOrExtend((err, status) => {
                        if (status === lock_manager_1.ELockStatus.locked) {
                            this.logger.info(`Workers are exclusively running from this instance (Lock ID ${this.lockManager.getId()}).`);
                        }
                        cb(err);
                    });
                },
                (cb) => {
                    this.workerPool.work(cb);
                },
            ], (err) => {
                if (!err || err instanceof lock_manager_acquire_error_1.LockManagerAcquireError)
                    this.ticker.nextTick();
                else
                    this.emit(events_2.events.ERROR, err);
            });
        };
        this.clearWorkerPool = (cb) => {
            this.workerPool.clear(cb);
        };
        this.stopTicker = (cb) => {
            this.ticker.once(events_2.events.DOWN, cb);
            this.ticker.quit();
        };
        this.releaseLock = (cb) => {
            this.lockManager.releaseLock(cb);
        };
        this.run = () => {
            this.emit(events_2.events.UP);
            this.ticker.nextTick();
        };
        this.quit = (cb) => {
            async_1.async.waterfall([this.stopTicker, this.clearWorkerPool, this.releaseLock], () => {
                this.emit(events_2.events.DOWN);
                cb();
            });
        };
        this.powerManager = new power_manager_1.PowerManager();
        this.redisClient = redisClient;
        this.logger = logger;
        this.lockManager = new lock_manager_1.LockManager(redisClient, keyLock, 60000);
        this.ticker = new ticker_1.Ticker(this.onTick);
        this.workerPool = workerPool;
    }
    addWorker(instance) {
        this.workerPool.add(instance);
    }
}
exports.WorkerRunner = WorkerRunner;
//# sourceMappingURL=worker-runner.js.map