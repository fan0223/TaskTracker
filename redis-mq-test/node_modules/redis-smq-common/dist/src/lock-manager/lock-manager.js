"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LockManager = exports.ELuaScript = exports.ELockStatus = void 0;
const redis_client_1 = require("../redis-client/redis-client");
const uuid_1 = require("uuid");
const lock_manager_abort_error_1 = require("./errors/lock-manager-abort.error");
const lock_manager_extend_error_1 = require("./errors/lock-manager-extend.error");
const lock_manager_acquire_error_1 = require("./errors/lock-manager-acquire.error");
const fs = require("fs");
const lock_manager_method_not_allowed_error_1 = require("./errors/lock-manager-method-not-allowed.error");
const lock_manager_not_acquired_error_1 = require("./errors/lock-manager-not-acquired.error");
const lock_manager_not_released_error_1 = require("./errors/lock-manager-not-released.error");
var ELockStatus;
(function (ELockStatus) {
    ELockStatus[ELockStatus["unlocked"] = 0] = "unlocked";
    ELockStatus[ELockStatus["locking"] = 1] = "locking";
    ELockStatus[ELockStatus["locked"] = 2] = "locked";
    ELockStatus[ELockStatus["releasing"] = 3] = "releasing";
    ELockStatus[ELockStatus["extending"] = 4] = "extending";
    ELockStatus[ELockStatus["extended"] = 5] = "extended";
})(ELockStatus = exports.ELockStatus || (exports.ELockStatus = {}));
var ELuaScript;
(function (ELuaScript) {
    ELuaScript["RELEASE_LOCK"] = "RELEASE_LOCK";
    ELuaScript["EXTEND_LOCK"] = "EXTEND_LOCK";
})(ELuaScript = exports.ELuaScript || (exports.ELuaScript = {}));
redis_client_1.RedisClient.addScript(ELuaScript.RELEASE_LOCK, fs.readFileSync(`${__dirname}/redis-client/lua/release-lock.lua`).toString());
redis_client_1.RedisClient.addScript(ELuaScript.EXTEND_LOCK, fs.readFileSync(`${__dirname}/redis-client/lua/extend-lock.lua`).toString());
class LockManager {
    constructor(redisClient, lockKey, ttl, retryOnFail = false, autoExtend = false, throwExceptions = true) {
        this.status = ELockStatus.unlocked;
        this.lockingTimer = null;
        this.autoExtendTimer = null;
        this.throwExceptions = true;
        this.lockKey = lockKey;
        this.ttl = ttl;
        this.retryOnFail = retryOnFail;
        this.lockId = (0, uuid_1.v4)();
        this.redisClient = redisClient;
        this.autoExtend = autoExtend;
        this.throwExceptions = throwExceptions;
    }
    resetTimers() {
        if (this.lockingTimer) {
            clearTimeout(this.lockingTimer);
            this.lockingTimer = null;
        }
        if (this.autoExtendTimer) {
            clearTimeout(this.autoExtendTimer);
            this.autoExtendTimer = null;
        }
    }
    setUnlocked() {
        this.status = ELockStatus.unlocked;
    }
    setLocked() {
        this.status = ELockStatus.locked;
    }
    setExtended() {
        this.status = ELockStatus.extended;
    }
    extend(cb) {
        if (!this.isLocked())
            cb(new lock_manager_not_acquired_error_1.LockManagerNotAcquiredError());
        else {
            this.status = ELockStatus.extending;
            this.redisClient.runScript(ELuaScript.EXTEND_LOCK, [this.lockKey], [this.lockId, this.ttl], (err, reply) => {
                if (err)
                    cb(err);
                else {
                    if (this.status === ELockStatus.extending) {
                        if (!reply) {
                            this.setUnlocked();
                            cb(new lock_manager_extend_error_1.LockManagerExtendError());
                        }
                        else {
                            this.setExtended();
                            cb();
                        }
                    }
                    else {
                        cb(new lock_manager_abort_error_1.LockManagerAbortError());
                    }
                }
            });
        }
    }
    runAutoExtendTimer() {
        const ms = Math.ceil(this.ttl / 2);
        this.autoExtendTimer = setTimeout(() => this.extend((err) => {
            if (!err)
                this.runAutoExtendTimer();
            else if (this.throwExceptions &&
                !(err instanceof lock_manager_abort_error_1.LockManagerAbortError))
                throw err;
        }), ms);
    }
    acquireLock(cb) {
        if (!this.isReleased())
            cb(new lock_manager_not_released_error_1.LockManagerNotReleasedError());
        else {
            this.status = ELockStatus.locking;
            const lock = () => {
                if (this.status === ELockStatus.locking) {
                    this.redisClient.set(this.lockKey, this.lockId, {
                        expire: {
                            mode: 'PX',
                            value: this.ttl,
                        },
                        exists: 'NX',
                    }, (err, reply) => {
                        if (err)
                            cb(err);
                        else if (this.status === ELockStatus.locking) {
                            if (!reply) {
                                if (this.retryOnFail)
                                    this.lockingTimer = setTimeout(lock, 1000);
                                else {
                                    this.setUnlocked();
                                    cb(new lock_manager_acquire_error_1.LockManagerAcquireError());
                                }
                            }
                            else {
                                this.setLocked();
                                if (this.autoExtend) {
                                    this.runAutoExtendTimer();
                                }
                                cb();
                            }
                        }
                        else {
                            cb(new lock_manager_abort_error_1.LockManagerAbortError());
                        }
                    });
                }
                else {
                    cb(new lock_manager_abort_error_1.LockManagerAbortError());
                }
            };
            lock();
        }
    }
    extendLock(cb) {
        if (this.autoExtend)
            cb(new lock_manager_method_not_allowed_error_1.LockManagerMethodNotAllowedError());
        else
            this.extend(cb);
    }
    releaseLock(cb) {
        const status = this.status;
        if (status === ELockStatus.unlocked)
            cb();
        else if (!this.isLocked())
            cb(new lock_manager_not_acquired_error_1.LockManagerNotAcquiredError());
        else {
            this.resetTimers();
            this.status = ELockStatus.releasing;
            this.redisClient.runScript(ELuaScript.RELEASE_LOCK, [this.lockKey], [this.lockId], (err) => {
                if (err)
                    cb(err);
                else {
                    this.setUnlocked();
                    cb();
                }
            });
        }
    }
    acquireOrExtend(cb) {
        if (this.autoExtend)
            cb(new lock_manager_method_not_allowed_error_1.LockManagerMethodNotAllowedError());
        else {
            const lock = () => {
                this.acquireLock((err) => {
                    if (err)
                        cb(err);
                    else
                        cb(null, ELockStatus.locked);
                });
            };
            if (this.isLocked())
                this.extend((err) => {
                    if (err) {
                        if (err instanceof lock_manager_extend_error_1.LockManagerExtendError)
                            lock();
                        else
                            cb(err);
                    }
                    else
                        cb(null, ELockStatus.extended);
                });
            else
                lock();
        }
    }
    isLocked() {
        return (this.status === ELockStatus.locked || this.status === ELockStatus.extended);
    }
    isReleased() {
        return this.status === ELockStatus.unlocked;
    }
    getId() {
        return this.lockId;
    }
}
exports.LockManager = LockManager;
//# sourceMappingURL=lock-manager.js.map